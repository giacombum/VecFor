var tipuesearch = {"pages":[{"text":"VecFor VecFor VecFor, Vector algebra class for Fortran poor people A KISS pure Fortran OOD class for computing Vectorial (3D) algebra VecFor is a pure Fortran (KISS) library for building easily nice Command Line Interfaces (CLI) for modern Fortran projects; VecFor is Fortran 2003+ standard compliant; VecFor is OOP designed; VecFor is a Free, Open Source Project. Table of Contents What is VecFor? Main features Copyrights Documentation A Taste of VecFor Issues Compiler Support What is VecFor? VecFor is a user-friendly and Object-Oriented designed API for handling vectors in a (3D) three dimensional frame of reference. It exposes (among others) the object Vector that posses a far complete set of overloaded operators for performing vectorial calculus algebra. VecFor adheres to the KISS concept: it is a pure Fortran (2003+) library coded into a single module file, vecfor.F90 . Go to Top Main features Pure Fortran implementation; KISS and user-friendly: simple API (one main object plus few other helpers ); easy building and porting on heterogeneous architectures: the vector components are defined as real with parametrized kind; the default kind parameter is set to be 64-bit-like finite precision (defined by means of the portable select_real_kind intrinsic function), but it can be easily changed at compile time; comprehensive (almost complete set of operators for vectorial calculus algebra); all operators accept mixed type/kind arguments: vectors can be mixed with integers and reals of any kinds by means of generic interfaces with dynamic dispatch resolved at compile time; efficient and non intrusive (all object methods and operators are pure or elemental ): threads/processes safe; Tests-Driven Developed ( TDD ); well documented: complete API reference; comprehensive wiki : collaborative developed on GitHub ; FOSS licensed ; Any feature request is welcome. Go to Top Copyrights VecFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to VecFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the VecFor documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of VecFor VecFor allows a very simple, high-level implementation of vectorial calculus algebra. Import VecFor use vecfor ! load vector type and all helpers Define some vector variables type ( vector ) :: point1 type ( vector ) :: point2 type ( vector ) :: distance Initialize vectors by high-level math-like syntax point1 = 1 * ex ! ex is the versor along x direction exposed by VecFor point2 = 1 * ex + 2 * ey ! ey is the versor along y direction exposed by VecFor Note that ex , ey and ez are the Cartesian versors exposed by VecFor. Perform vectorial calculus algebra distance = point2 - ponint1 Use helper methods to simplify your life print \"(A)\" , \" Vectorial distance\" call distance % print print \"(A)\" , \" Distance module\" print * , distance % normL2 () ! expected output !   Vectorial distance !   Component x  0.000000000000000E+000 !   Component y +0.200000000000000E+001 !   Component z  0.000000000000000E+000 !   Distance module !   +0.200000000000000E+001 As you can see from the above example, defining and using a vector become very close to the mathematical formulation. Note that, using the dynamic dispatching resolved at compile time, there is no performance penalty on using a type(vector) variable instead of an hard-coded real, dimension(3) array variable (or even more verbose and less clear real :: x, y, z variables for each vector…). Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" VecFor "},{"text":"VecFor, Vector algebra class for Fortran poor people This File Depends On sourcefile~~vecfor.f90~~EfferentGraph sourcefile~vecfor.f90 vecfor.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefilevecforf90EfferentGraph = svgPanZoom('#sourcefilevecforf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~vecfor.f90~~AfferentGraph sourcefile~vecfor.f90 vecfor.F90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules vecfor Source Code vecfor.F90 Source Code !< VecFor, Vector algebra class for Fortran poor people module vecfor !< VecFor, Vector algebra class for Fortran poor people !< !< This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with !< parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of !< reference. !< All the vectorial math procedures (cross, dot products, parallel...) assume a three-dimensional cartesian frame of reference. !< The operators of assignment (`=`), multiplication (`*`), division (`/`), sum (`+`) and subtraction (`-`) have been overloaded. !< Furthermore the *dot* and *cross* products have been defined. !< Therefore this module provides a far-complete algebra based on Vector derived type. use , intrinsic :: iso_fortran_env , only : stdout => output_unit use penf , only : DR8P , FR8P , I1P , I2P , I4P , I8P , R_P , R4P , R8P , R16P , smallR_P , str implicit none private public :: ex , ey , ez public :: sq_norm public :: normL2 public :: normalize public :: face_normal3 , face_normal4 public :: vector type :: vector !< Vector class. real ( R_P ) :: x = 0._R_P !< Cartesian component in x direction. real ( R_P ) :: y = 0._R_P !< Cartesian component in y direction. real ( R_P ) :: z = 0._R_P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype vector type , public :: vector_ptr !< Pointer of Vector for creating array of pointers of Vector. type ( vector ), pointer :: p => null () endtype vector_ptr type ( vector ), parameter :: ex = Vector ( 1._R_P , 0._R_P , 0._R_P ) !< X direction versor. type ( vector ), parameter :: ey = Vector ( 0._R_P , 1._R_P , 0._R_P ) !< Y direction versor. type ( vector ), parameter :: ez = Vector ( 0._R_P , 0._R_P , 1._R_P ) !< Z direction versor. contains elemental function sq_norm ( vec ) result ( sq ) !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . type ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: sq !< Square of the Norm. sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) endfunction sq_norm elemental function normL2 ( vec ) result ( norm ) !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . type ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: norm !< Norm L2. norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) endfunction normL2 elemental function normalize ( vec ) result ( norm ) !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. type ( vector ), intent ( in ) :: vec !< Vector to be normalized. type ( vector ) :: norm !< Vector normalized. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm endfunction normalize elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. type ( vector ), intent ( in ) :: pt4 !< Fourth face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: fnormal !< Face normal. type ( vector ) :: d13 !< Face 1-3 diagonal. type ( vector ) :: d24 !< Face 2-4 diagonal. d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R_P * ( d13 . cross . d24 ) endif endfunction face_normal4 elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: fnormal !< Face normal. type ( vector ) :: s12 !< Face 1-2 diagonals. type ( vector ) :: s13 !< Face 1-3 diagonals. s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R_P * ( s12 . cross . s13 ) endif endfunction face_normal3 elemental subroutine init_vector_self ( vec ) !< Initialize components of Vector variable. class ( vector ), intent ( inout ) :: vec !< Vector. vec % x = 0._R_P vec % y = 0._R_P vec % z = 0._R_P endsubroutine init_vector_self elemental subroutine set_vector_self ( vec , x , y , z ) !< Set components of Vector variable. class ( vector ), intent ( inout ) :: vec !< Vector. real ( R_P ), intent ( in ), optional :: x !< Cartesian component in x direction. real ( R_P ), intent ( in ), optional :: y !< Cartesian component in y direction. real ( R_P ), intent ( in ), optional :: z !< Cartesian component in z direction. if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z endsubroutine set_vector_self function iolen_vector_self ( vec ) result ( iolen ) !< Compute IO length. class ( vector ), intent ( in ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. inquire ( iolength = iolen ) vec % x , vec % y , vec % z endfunction iolen_vector_self subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !< Load Vector data. class ( vector ), intent ( inout ) :: vec !< Vector data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. integer ( I8P ), intent ( in ), optional :: pos !< Position specifier. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine load_vector_self subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !< Save Vector data. class ( vector ), intent ( in ) :: vec !< Vector data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. integer ( I8P ), intent ( in ), optional :: pos !< Position specifier. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine save_vector_self subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !< Print in a pretty ascii format the components of type Vector. class ( vector ), intent ( in ) :: vec !< Vector. integer ( I4P ), intent ( in ), optional :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string for outputs. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine print_vector_self elemental subroutine normalize_self ( vec ) !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. class ( vector ), intent ( inout ) :: vec !< Vector to be normalized. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm endsubroutine normalize_self elemental function normalized_self ( vec ) result ( norm ) !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. class ( vector ), intent ( in ) :: vec !< Vector to be normalized. type ( vector ) :: norm !< Normalized copy. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm endfunction normalized_self elemental function sq_norm_self ( vec ) result ( sq ) !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . class ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: sq !< Square of the Norm. sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) endfunction sq_norm_self elemental function normL2_self ( vec ) result ( norm ) !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . class ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: norm !< Norm L2. norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) endfunction normL2_self elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). class ( vector ), intent ( inout ) :: fnormal !< Face normal. type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. type ( vector ), intent ( in ) :: pt4 !< Fourth face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: d13 !< Face 1-3 diagonals. type ( vector ) :: d24 !< Face 2-4 diagonals. d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R_P * ( d13 . cross . d24 ) endif endsubroutine face_normal4_self elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). class ( vector ), intent ( inout ) :: fnormal !< Face normal. type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: s12 !< Face 1-2 diagonals. type ( vector ) :: s13 !< Face 1-3 diagonals. s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R_P * ( s12 . cross . s13 ) endif endsubroutine face_normal3_self elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: cross !< Cross product vector. cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) endfunction crossproduct elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. real ( R_P ) :: dot !< Dot product. dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) endfunction dotproduct elemental function parallel ( vec1 , vec2 ) result ( paral ) !> Compute the component of vec1 parallel to vec2. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: paral !< Component of of vec1 parallel to vec2. paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) endfunction parallel elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !< Compute the component of vec1 orthogonal to vec2. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: ortho !< Component of of vec1 orthogonal to vec2. ortho = vec1 - ( vec1 . paral . vec2 ) endfunction orthogonal ! Operators overloading. ! Operator (=) pure subroutine assign_self ( self1 , self2 ) !< Assignment between two selfs. class ( vector ), intent ( inout ) :: self1 !< Left hand side. class ( vector ), intent ( in ) :: self2 !< Right hand side. self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z endsubroutine assign_self elemental subroutine assign_ScalR16P ( self , scal ) !< Assignment between a scalar (real R16P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR16P elemental subroutine assign_ScalR8P ( self , scal ) !< Assignment between a scalar (real R8P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR8P elemental subroutine assign_ScalR4P ( self , scal ) !< Assignment between a scalar (real R4P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR4P elemental subroutine assign_ScalI8P ( self , scal ) !< Assignment between a scalar (integer I8P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI8P elemental subroutine assign_ScalI4P ( self , scal ) !< Assignment between a scalar (integer I4P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI4P elemental subroutine assign_ScalI2P ( self , scal ) !< Assignment between a scalar (integer I2P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI2P elemental subroutine assign_ScalI1P ( self , scal ) !< Assignment between a scalar (integer I1P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI1P ! Operator (*) elemental function self_mul_self ( self1 , self2 ) result ( mul ) !< Multiply (by components) two selfs. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z endfunction self_mul_self elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R16P) for self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR16P_mul_self elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR16P elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R8P) for self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR8P_mul_self elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR8P elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R4P) for self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR4P_mul_self elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR4P elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I8P) for self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI8P_mul_self elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI8P elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I4P) for self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI4P_mul_self elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI4P elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I2P) for self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI2P_mul_self elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI2P elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I1P) for self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI1P_mul_self elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI1P ! Operator (/) elemental function self_div_self ( self1 , self2 ) result ( div ) !< Divide self for self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z endfunction self_div_self elemental function self_div_ScalR16P ( self , scal ) result ( div ) !< Divide self for scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR16P elemental function self_div_ScalR8P ( self , scal ) result ( div ) !< Divide self for scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR8P elemental function self_div_ScalR4P ( self , scal ) result ( div ) !< Divide self for scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR4P elemental function self_div_ScalI8P ( self , scal ) result ( div ) !< Divide self for scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI8P elemental function self_div_ScalI4P ( self , scal ) result ( div ) !< Divide self for scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI4P elemental function self_div_ScalI2P ( self , scal ) result ( div ) !< Divide self for scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI2P elemental function self_div_ScalI1P ( self , scal ) result ( div ) !< Divide self for scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI1P ! Operator (+) elemental function positive_self ( self ) result ( pos ) !< Applay unary + to a self. class ( vector ), intent ( in ) :: self !< Unary object. type ( vector ) :: pos !< Operator result. pos % x = + self % x pos % y = + self % y pos % z = + self % z endfunction positive_self elemental function self_sum_self ( self1 , self2 ) result ( summ ) !< Sum self and self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z endfunction self_sum_self elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R16P) and self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR16P_sum_self elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !< Sum self and scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR16P elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R8P) and self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR8P_sum_self elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !< Sum self and scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR8P elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R4P) and self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR4P_sum_self elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !< Sum self and scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR4P elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I8P) and self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI8P_sum_self elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI8P elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I4P) and self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI4P_sum_self elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI4P elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I2P) and self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI2P_sum_self elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI2P elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I1P) and self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI1P_sum_self elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI1P ! Operator (-) elemental function negative_self ( self ) result ( neg ) !< Applay unary - to a self. class ( vector ), intent ( in ) :: self !< Unary object. type ( vector ) :: neg !< Operator result. neg % x = - self % x neg % y = - self % y neg % z = - self % z endfunction negative_self elemental function self_sub_self ( self1 , self2 ) result ( sub ) !< Subtract self and self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z endfunction self_sub_self elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R16P) and self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR16P_sub_self elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR16P elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R8P) and self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR8P_sub_self elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR8P elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R4P) and self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR4P_sub_self elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR4P elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I8P) and self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI8P_sub_self elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI8P elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I4P) and self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI4P_sub_self elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI4P elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I2P) and self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI2P_sub_self elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI2P elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I1P) and self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI1P_sub_self elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI1P ! Conditional operators ! Oprator /= elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< First selftor. type ( vector ), intent ( in ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( vector ) :: n1 !< Normalizations of self1. type ( vector ) :: n2 !< Normalizations of self2. compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif endfunction self_not_eq_self elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R16P_not_eq_self elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R16P elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R8P_not_eq_self elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R8P elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R4P_not_eq_self elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R4P elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I8P_not_eq_self elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I8P elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I4P_not_eq_self elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I4P elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I2P_not_eq_self elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I2P elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I1P_not_eq_self elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I1P ! Oprator < elemental function self_low_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) < normL2 ( self2 )) endfunction self_low_self elemental function R16P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R16P_low_self elemental function self_low_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R16P elemental function R8P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R8P_low_self elemental function self_low_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R8P elemental function R4P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R4P_low_self elemental function self_low_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R4P elemental function I8P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I8P_low_self elemental function self_low_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I8P elemental function I4P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I4P_low_self elemental function self_low_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I4P elemental function I2P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I2P_low_self elemental function self_low_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I2P elemental function I1P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I1P_low_self elemental function self_low_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I1P ! Oprator <= elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) <= normL2 ( self2 )) endfunction self_low_eq_self elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R16P_low_eq_self elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R16P elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R8P_low_eq_self elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R8P elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R4P_low_eq_self elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R4P elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I8P_low_eq_self elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I8P elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I4P_low_eq_self elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I4P elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I2P_low_eq_self elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I2P elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I1P_low_eq_self elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I1P ! Oprator == elemental function self_eq_self ( self1 , self2 ) result ( compare ) !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. type ( vector ) :: n1 !< Normalizations of self1. type ( vector ) :: n2 !< Normalizations of self2. compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif endfunction self_eq_self elemental function R16P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R16P_eq_self elemental function self_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R16P elemental function R8P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R8P_eq_self elemental function self_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R8P elemental function R4P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R4P_eq_self elemental function self_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R4P elemental function I8P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I8P_eq_self elemental function self_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I8P elemental function I4P_eq_self ( scal , self ) result ( compare ) !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I4P_eq_self elemental function self_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I4P elemental function I2P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I2P_eq_self elemental function self_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I2P elemental function I1P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I1P_eq_self elemental function self_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I1P ! Oprator >= elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) >= normL2 ( self2 )) endfunction self_great_eq_self elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R16P_great_eq_self elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R16P elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R8P_great_eq_self elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R8P elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R4P_great_eq_self elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R4P elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I8P_great_eq_self elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I8P elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I4P_great_eq_self elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I4P elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I2P_great_eq_self elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I2P elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I1P_great_eq_self elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I1P ! Oprator > elemental function self_great_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) > normL2 ( self2 )) endfunction self_great_self elemental function R16P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R16P_great_self elemental function self_great_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R16P elemental function R8P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R8P_great_self elemental function self_great_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R8P elemental function R4P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R4P_great_self elemental function self_great_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R4P elemental function I8P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I8P_great_self elemental function self_great_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I8P elemental function I4P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I4P_great_self elemental function self_great_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I4P elemental function I2P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I2P_great_self elemental function self_great_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I2P elemental function I1P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I1P_great_self elemental function self_great_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I1P endmodule vecfor","tags":"","loc":"sourcefile/vecfor.f90.html","title":"vecfor.F90 – VecFor"},{"text":"Kinds regression test for VecFor library. This File Depends On sourcefile~~kinds.f90~~EfferentGraph sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefilekindsf90EfferentGraph = svgPanZoom('#sourcefilekindsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs kinds Source Code kinds.f90 Source Code !< Kinds regression test for VecFor library. program kinds !< Kinds regression test for VecFor library. !< !< Try to test the algebra of mixed vector/numbers for all supported kinds. use vecfor implicit none #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. call vector1 % set ( x =- 1._R8P , y =- 1._R8P , z =- 1._R8P ) call vector1 % init () print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [1, 1, 1] testing assignments by scalar' vector2 = 1._R16P vector2 = 1._R8P vector2 = 1._R4P vector2 = 1_I8P vector2 = 1_I4P vector2 = 1_I2P vector2 = 1_I1P print \"(A)\" , ' Verify * operator, multiply by 1 defined in any supported number formats' vector1 = 1._R16P * vector1 vector1 = 1._R8P * vector1 vector1 = 1._R4P * vector1 vector1 = 1_I8P * vector1 vector1 = 1_I4P * vector1 vector1 = 1_I2P * vector1 vector1 = 1_I1P * vector1 vector1 = vector1 * 1._R16P vector1 = vector1 * 1._R8P vector1 = vector1 * 1._R4P vector1 = vector1 * 1_I8P vector1 = vector1 * 1_I4P vector1 = vector1 * 1_I2P vector1 = vector1 * 1_I1P call vector1 % print print \"(A)\" , ' Verify * operator between vectors, vector1 * vector2' vector1 = vector1 * vector2 call vector1 % print print \"(A)\" , ' Verify / operator, diveded by 1 defined in any supported number formats' vector1 = vector1 / 1._R16P vector1 = vector1 / 1._R8P vector1 = vector1 / 1._R4P vector1 = vector1 / 1_I8P vector1 = vector1 / 1_I4P vector1 = vector1 / 1_I2P vector1 = vector1 / 1_I1P call vector1 % print print \"(A)\" , ' Verify / operator between vectors, vector1 / vector2' vector1 = vector1 / vector2 call vector1 % print print \"(A)\" , ' Verify + operator, add 1 (14 times) defined in any supported number formats' vector1 = 1._R16P + vector1 vector1 = 1._R8P + vector1 vector1 = 1._R4P + vector1 vector1 = 1_I8P + vector1 vector1 = 1_I4P + vector1 vector1 = 1_I2P + vector1 vector1 = 1_I1P + vector1 vector1 = + vector1 vector1 = vector1 + 1._R16P vector1 = vector1 + 1._R8P vector1 = vector1 + 1._R4P vector1 = vector1 + 1_I8P vector1 = vector1 + 1_I4P vector1 = vector1 + 1_I2P vector1 = vector1 + 1_I1P call vector1 % print print \"(A)\" , ' Verify + operator between vectors, vector1 + vector2' vector1 = vector1 + vector2 call vector1 % print print \"(A)\" , ' Verify - operator, subtract 1 (14 times) defined in any supported number formats' vector1 = 1._R16P - vector1 vector1 =- 1._R8P - vector1 vector1 = 1._R4P - vector1 vector1 =- 1_I8P - vector1 vector1 = 1_I4P - vector1 vector1 =- 1_I2P - vector1 vector1 = 1_I1P - vector1 vector1 = - vector1 vector1 = vector1 - 1._R16P vector1 = vector1 - 1._R8P vector1 = vector1 - 1._R4P vector1 = vector1 - 1_I8P vector1 = vector1 - 1_I4P vector1 = vector1 - 1_I2P vector1 = vector1 - 1_I1P call vector1 % print print \"(A)\" , ' Verify - operator between vectors, vector1 - vector2' vector1 = vector1 - vector2 call vector1 % print print \"(A)\" , ' Verify save/load methods' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' ) call vector1 % save ( unit = 2 ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 ) close ( unit = 2 ) call vector3 % print vector3 = 0 print \"(A)\" , ' Verify save/load methods with stream-accessed file' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' , access = 'STREAM' ) call vector1 % save ( unit = 2 , pos = 1_I8P ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 , pos = 1_I8P ) close ( unit = 2 ) call vector3 % print print \"(A)\" , ' Verify < operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<1._R16P => ' , ( vector1 < 1._R16P ) print \"(A,L1)\" , 'vector1<1._R8P  => ' , ( vector1 < 1._R8P ) print \"(A,L1)\" , 'vector1<1._R4P  => ' , ( vector1 < 1._R4P ) print \"(A,L1)\" , 'vector1<1_I8P   => ' , ( vector1 < 1_I8P ) print \"(A,L1)\" , 'vector1<1_I4P   => ' , ( vector1 < 1_I4P ) print \"(A,L1)\" , 'vector1<1_I2P   => ' , ( vector1 < 1_I2P ) print \"(A,L1)\" , 'vector1<1_I1P   => ' , ( vector1 < 1_I1P ) print \"(A,L1)\" , '1._R16P<vector1 => ' , ( 1._R16P < vector1 ) print \"(A,L1)\" , '1._R8P <vector1 => ' , ( 1._R8P < vector1 ) print \"(A,L1)\" , '1._R4P <vector1 => ' , ( 1._R4P < vector1 ) print \"(A,L1)\" , '1_I8P  <vector1 => ' , ( 1_I8P < vector1 ) print \"(A,L1)\" , '1_I4P  <vector1 => ' , ( 1_I4P < vector1 ) print \"(A,L1)\" , '1_I2P  <vector1 => ' , ( 1_I2P < vector1 ) print \"(A,L1)\" , '1_I1P  <vector1 => ' , ( 1_I1P < vector1 ) print \"(A,L1)\" , 'vector1<vector2 => ' , ( vector1 < vector2 ) print \"(A)\" , ' Verify <= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<=1._R16P => ' , ( vector1 <= 1._R16P ) print \"(A,L1)\" , 'vector1<=1._R8P  => ' , ( vector1 <= 1._R8P ) print \"(A,L1)\" , 'vector1<=1._R4P  => ' , ( vector1 <= 1._R4P ) print \"(A,L1)\" , 'vector1<=1_I8P   => ' , ( vector1 <= 1_I8P ) print \"(A,L1)\" , 'vector1<=1_I4P   => ' , ( vector1 <= 1_I4P ) print \"(A,L1)\" , 'vector1<=1_I2P   => ' , ( vector1 <= 1_I2P ) print \"(A,L1)\" , 'vector1<=1_I1P   => ' , ( vector1 <= 1_I1P ) print \"(A,L1)\" , '1._R16P<=vector1 => ' , ( 1._R16P <= vector1 ) print \"(A,L1)\" , '1._R8P <=vector1 => ' , ( 1._R8P <= vector1 ) print \"(A,L1)\" , '1._R4P <=vector1 => ' , ( 1._R4P <= vector1 ) print \"(A,L1)\" , '1_I8P  <=vector1 => ' , ( 1_I8P <= vector1 ) print \"(A,L1)\" , '1_I4P  <=vector1 => ' , ( 1_I4P <= vector1 ) print \"(A,L1)\" , '1_I2P  <=vector1 => ' , ( 1_I2P <= vector1 ) print \"(A,L1)\" , '1_I1P  <=vector1 => ' , ( 1_I1P <= vector1 ) print \"(A,L1)\" , 'vector1<=vector2 => ' , ( vector1 <= vector2 ) print \"(A)\" , ' Verify == operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1==1._R16P => ' , ( vector1 == 1._R16P ) print \"(A,L1)\" , 'vector1==1._R8P  => ' , ( vector1 == 1._R8P ) print \"(A,L1)\" , 'vector1==1._R4P  => ' , ( vector1 == 1._R4P ) print \"(A,L1)\" , 'vector1==1_I8P   => ' , ( vector1 == 1_I8P ) print \"(A,L1)\" , 'vector1==1_I4P   => ' , ( vector1 == 1_I4P ) print \"(A,L1)\" , 'vector1==1_I2P   => ' , ( vector1 == 1_I2P ) print \"(A,L1)\" , 'vector1==1_I1P   => ' , ( vector1 == 1_I1P ) print \"(A,L1)\" , '1._R16P==vector1 => ' , ( 1._R16P == vector1 ) print \"(A,L1)\" , '1._R8P ==vector1 => ' , ( 1._R8P == vector1 ) print \"(A,L1)\" , '1._R4P ==vector1 => ' , ( 1._R4P == vector1 ) print \"(A,L1)\" , '1_I8P  ==vector1 => ' , ( 1_I8P == vector1 ) print \"(A,L1)\" , '1_I4P  ==vector1 => ' , ( 1_I4P == vector1 ) print \"(A,L1)\" , '1_I2P  ==vector1 => ' , ( 1_I2P == vector1 ) print \"(A,L1)\" , '1_I1P  ==vector1 => ' , ( 1_I1P == vector1 ) print \"(A,L1)\" , 'vector1==vector2 => ' , ( vector1 == vector2 ) print \"(A,L1)\" , 'vector1==-vector1 => ' , ( vector1 ==- vector1 ) print \"(A)\" , ' Verify /= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1/=1._R16P => ' , ( vector1 /= 1._R16P ) print \"(A,L1)\" , 'vector1/=1._R8P  => ' , ( vector1 /= 1._R8P ) print \"(A,L1)\" , 'vector1/=1._R4P  => ' , ( vector1 /= 1._R4P ) print \"(A,L1)\" , 'vector1/=1_I8P   => ' , ( vector1 /= 1_I8P ) print \"(A,L1)\" , 'vector1/=1_I4P   => ' , ( vector1 /= 1_I4P ) print \"(A,L1)\" , 'vector1/=1_I2P   => ' , ( vector1 /= 1_I2P ) print \"(A,L1)\" , 'vector1/=1_I1P   => ' , ( vector1 /= 1_I1P ) print \"(A,L1)\" , '1._R16P/=vector1 => ' , ( 1._R16P /= vector1 ) print \"(A,L1)\" , '1._R8P /=vector1 => ' , ( 1._R8P /= vector1 ) print \"(A,L1)\" , '1._R4P /=vector1 => ' , ( 1._R4P /= vector1 ) print \"(A,L1)\" , '1_I8P  /=vector1 => ' , ( 1_I8P /= vector1 ) print \"(A,L1)\" , '1_I4P  /=vector1 => ' , ( 1_I4P /= vector1 ) print \"(A,L1)\" , '1_I2P  /=vector1 => ' , ( 1_I2P /= vector1 ) print \"(A,L1)\" , '1_I1P  /=vector1 => ' , ( 1_I1P /= vector1 ) print \"(A,L1)\" , 'vector1/=vector2 => ' , ( vector1 /= vector2 ) print \"(A,L1)\" , 'vector1/=-vector1 => ' , ( vector1 /=- vector1 ) print \"(A)\" , ' Verify >= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>=1._R16P => ' , ( vector1 >= 1._R16P ) print \"(A,L1)\" , 'vector1>=1._R8P  => ' , ( vector1 >= 1._R8P ) print \"(A,L1)\" , 'vector1>=1._R4P  => ' , ( vector1 >= 1._R4P ) print \"(A,L1)\" , 'vector1>=1_I8P   => ' , ( vector1 >= 1_I8P ) print \"(A,L1)\" , 'vector1>=1_I4P   => ' , ( vector1 >= 1_I4P ) print \"(A,L1)\" , 'vector1>=1_I2P   => ' , ( vector1 >= 1_I2P ) print \"(A,L1)\" , 'vector1>=1_I1P   => ' , ( vector1 >= 1_I1P ) print \"(A,L1)\" , '1._R16P>=vector1 => ' , ( 1._R16P >= vector1 ) print \"(A,L1)\" , '1._R8P >=vector1 => ' , ( 1._R8P >= vector1 ) print \"(A,L1)\" , '1._R4P >=vector1 => ' , ( 1._R4P >= vector1 ) print \"(A,L1)\" , '1_I8P  >=vector1 => ' , ( 1_I8P >= vector1 ) print \"(A,L1)\" , '1_I4P  >=vector1 => ' , ( 1_I4P >= vector1 ) print \"(A,L1)\" , '1_I2P  >=vector1 => ' , ( 1_I2P >= vector1 ) print \"(A,L1)\" , '1_I1P  >=vector1 => ' , ( 1_I1P >= vector1 ) print \"(A,L1)\" , 'vector1>=vector2 => ' , ( vector1 >= vector2 ) print \"(A)\" , ' Verify > operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>1._R16P => ' , ( vector1 > 1._R16P ) print \"(A,L1)\" , 'vector1>1._R8P  => ' , ( vector1 > 1._R8P ) print \"(A,L1)\" , 'vector1>1._R4P  => ' , ( vector1 > 1._R4P ) print \"(A,L1)\" , 'vector1>1_I8P   => ' , ( vector1 > 1_I8P ) print \"(A,L1)\" , 'vector1>1_I4P   => ' , ( vector1 > 1_I4P ) print \"(A,L1)\" , 'vector1>1_I2P   => ' , ( vector1 > 1_I2P ) print \"(A,L1)\" , 'vector1>1_I1P   => ' , ( vector1 > 1_I1P ) print \"(A,L1)\" , '1._R16P>vector1 => ' , ( 1._R16P > vector1 ) print \"(A,L1)\" , '1._R8P >vector1 => ' , ( 1._R8P > vector1 ) print \"(A,L1)\" , '1._R4P >vector1 => ' , ( 1._R4P > vector1 ) print \"(A,L1)\" , '1_I8P  >vector1 => ' , ( 1_I8P > vector1 ) print \"(A,L1)\" , '1_I4P  >vector1 => ' , ( 1_I4P > vector1 ) print \"(A,L1)\" , '1_I2P  >vector1 => ' , ( 1_I2P > vector1 ) print \"(A,L1)\" , '1_I1P  >vector1 => ' , ( 1_I1P > vector1 ) print \"(A,L1)\" , 'vector1>vector2 => ' , ( vector1 > vector2 ) stop endprogram kinds","tags":"","loc":"sourcefile/kinds.f90.html","title":"kinds.f90 – VecFor"},{"text":"Simple regression test for VecFor library. This File Depends On sourcefile~~simple.f90~~EfferentGraph sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~simple.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefilesimplef90EfferentGraph = svgPanZoom('#sourcefilesimplef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs simple Source Code simple.f90 Source Code !< Simple regression test for VecFor library. program simple !< Simple regression test for VecFor library. use vecfor implicit none type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. type ( vector ) :: vector4 !< Vector dummy variable. type ( vector ) :: vector5 !< Vector dummy variable. print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [-1, -2, -3]' vector2 = - 1 * ex - 2 * ey - 3 * ez print \"(A)\" , ' Verify auxiliary methods' print \"(A,F5.1)\" , ' vector1%sq_norm() = ' , vector1 % sq_norm () print \"(A,F5.1)\" , ' sq_norm(vector1) = ' , sq_norm ( vector1 ) print \"(A,F5.1)\" , ' vector1%normL2() = ' , vector1 % normL2 () print \"(A,F5.1)\" , ' normL2(vector1) = ' , normL2 ( vector1 ) print \"(A)\" , ' normalized(vector1):' vector3 = vector1 % normalized () call vector3 % print print \"(A)\" , 'call vector1%normalize():' vector3 = vector1 call vector3 % normalize () call vector3 % print print \"(A)\" , ' Verify normalization fall-back for null vector' vector3 = 0 call vector3 % normalize () print \"(A)\" , 'call 0%normalize():' call vector3 % print vector3 = 0 vector3 = vector3 % normalized () print \"(A)\" , 'vector1 = 0%normalized():' call vector3 % print print \"(A)\" , ' Verify dot product' print \"(A,F5.1)\" , ' vector1.dot.ex = ' , vector1 . dot . ex print \"(A,F5.1)\" , ' vector1.dot.ey = ' , vector1 . dot . ey print \"(A,F5.1)\" , ' vector1.dot.ez = ' , vector1 . dot . ez print \"(A,F5.1)\" , ' vector1.dot.vector2 = ' , vector1 . dot . vector2 print \"(A)\" , ' Verify cross product' print \"(A)\" , ' vector1.cross.vector2:' vector3 = vector1 . cross . vector2 call vector3 % print print \"(A)\" , ' Verify special operators' print \"(A)\" , ' vector1.ortho.vector2:' vector3 = vector1 . ortho . vector2 call vector3 % print print \"(A)\" , ' vector1.paral.vector2:' vector3 = vector1 . paral . vector2 call vector3 % print print \"(A)\" , ' Verify * / + - operators' print \"(A)\" , ' vector1 * vector2:' vector3 = vector1 * vector2 call vector3 % print print \"(A)\" , ' vector1 / vector2:' vector3 = vector1 / vector2 call vector3 % print print \"(A)\" , ' vector1 + vector2:' vector3 = vector1 + vector2 call vector3 % print print \"(A)\" , ' vector1 - vector2:' vector3 = vector1 - vector2 call vector3 % print print \"(A)\" , ' Assign vector1 = [-1, 1, 0]' vector1 = - ex + ey print \"(A)\" , ' Assign vector2 = [0, 1, 0]' vector2 = ey print \"(A)\" , ' Assign vector3 = [0, -1, 0]' vector3 = - ey print \"(A)\" , ' Assign vector4 = [-1, -1, 0]' vector4 = - ex - ey print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure):' vector5 = face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure, normalized):' vector5 = face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method):' call vector5 % face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method, normalized):' call vector5 % face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure): ' vector5 = face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure, normalized): ' vector5 = face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method):' call vector5 % face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method, normalized):' call vector5 % face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A,I3)\" , ' IO length of vector1 = ' , vector1 % iolen () stop endprogram simple","tags":"","loc":"sourcefile/simple.f90.html","title":"simple.f90 – VecFor"},{"text":"Portability Environment for Fortran poor people. This File Depends On sourcefile~~penf.f90~~EfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf.f90~~AfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !< Portability Environment for Fortran poor people. use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton implicit none private save ! global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! bit/byte size functions public :: bit_size , byte_size ! stringify facility public :: str , strz , cton public :: bstr , bcton ! miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface contains subroutine check_endian () !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. if ( is_little_endian ()) then endian = endianL else endian = endianB endif contains pure function is_little_endian () result ( is_little ) !< Check if the type of the bit ordering of the running architecture is little endian. logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I1 subroutine penf_init () !< Initialize PENF's variables that are not initialized into the definition specification. call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P ! #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P ! #else ! BIR16P = int(BIR8P, kind=I2P) ; BYR16P = BIR16P/8_I2P ! #endif is_initialized = . true . endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !< Print to the specified unit the PENF's environment data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = R_P ) // ',' // FR_P // ',' // str ( n = DR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = MinR_P ) // ',' // str ( n = MaxR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = BIR_P ) // '/' // str ( n = BYR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   Zero:    ' // str ( Zero ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – VecFor"},{"text":"PENF bit/byte size functions. This File Depends On sourcefile~~penf_b_size.f90~~EfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_b_size.f90~~AfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_b_size Source Code penf_b_size.F90 Source Code !< PENF bit/byte size functions. module penf_b_size !< PENF bit/byte size functions. use penf_global_parameters_variables implicit none private save public :: bit_size , byte_size interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface contains elemental function bit_size_R16P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !< Compute the number of bits of a character variable. character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !< Compute the number of bytes of a character variable. character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. bytes = bit_size ( i ) / 8_I4P endfunction byte_size_chr endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html","title":"penf_b_size.F90 – VecFor"},{"text":"PENF global parameters and variables. Files Dependent On This One sourcefile~~penf_global_parameters_variables.f90~~AfferentGraph sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 var pansourcefilepenf_global_parameters_variablesf90AfferentGraph = svgPanZoom('#sourcefilepenf_global_parameters_variablesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code !< PENF global parameters and variables. module penf_global_parameters_variables !< PENF global parameters and variables. !< !< @note All module defined entities are public. implicit none public save logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). ! portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. #ifdef r16p integer , parameter :: R_P = R16P !< Default real precision. #else integer , parameter :: R_P = R8P !< Default real precision. #endif integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. ! format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. #ifdef r16p character ( * ), parameter :: FR_P = FR16P !< Output format for kind=R_P real. #else character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. #endif character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. ! length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. #ifdef r16p integer , parameter :: DR_P = DR16P !< Number of digits of output format FR_P. #else integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. #endif integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. ! list of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. ! minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = - huge ( 1._R_P ) !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = huge ( 1._R_P ) !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = - huge ( 1_I_P ) !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = huge ( 1_I_P ) !< Maximum value of kind=I_P integer. ! real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = tiny ( 1._R_P ) !< Smallest representable value of kind=R_P real. ! smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = nearest ( 1._R_P , 1._R_P ) - & nearest ( 1._R_P , - 1._R_P ) !< Smallest representable difference of kind=R_P real. ! bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html","title":"penf_global_parameters_variables.F90 – VecFor"},{"text":"PENF string-to-number (and viceversa) facility. This File Depends On sourcefile~~penf_stringify.f90~~EfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_stringify.f90~~AfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~penf.f90->sourcefile~vecfor.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~vecfor.f90->sourcefile~kinds.f90 sourcefile~simple.f90 simple.f90 sourcefile~vecfor.f90->sourcefile~simple.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_stringify Source Code penf_stringify.F90 Source Code !< PENF string-to-number (and viceversa) facility. module penf_stringify !< PENF string-to-number (and viceversa) facility. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf_b_size use penf_global_parameters_variables implicit none private save public :: str , strz , cton public :: bstr , bcton interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface contains elemental function strf_R16P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !< Converting integer to string. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I1P elemental function str_bol ( n ) result ( str ) !< Convert logical to string. logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. write ( str , '(L1)' ) n endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Converting real array to string. real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I1P pure subroutine compact_real_string ( string ) !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !< Converting integer to string, prefixing with the right number of zeros. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B128.128)' ) n endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B64.64)' ) n endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B32.32)' ) n endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B64.64)' ) n endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B32.32)' ) n endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B16.16)' ) n endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B8.8)' ) n endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html","title":"penf_stringify.F90 – VecFor"},{"text":"type, public :: vector Vector class. Inherited By type~~vector~~InheritedByGraph type~vector vector type~vector_ptr vector_ptr type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables x y z Type-Bound Procedures I1P_eq_self I1P_great_eq_self I1P_great_self I1P_low_eq_self I1P_low_self I1P_not_eq_self I2P_eq_self I2P_great_eq_self I2P_great_self I2P_low_eq_self I2P_low_self I2P_not_eq_self I4P_eq_self I4P_great_eq_self I4P_great_self I4P_low_eq_self I4P_low_self I4P_not_eq_self I8P_eq_self I8P_great_eq_self I8P_great_self I8P_low_eq_self I8P_low_self I8P_not_eq_self R4P_eq_self R4P_great_eq_self R4P_great_self R4P_low_eq_self R4P_low_self R4P_not_eq_self R8P_eq_self R8P_great_eq_self R8P_great_self R8P_low_eq_self R8P_low_self R8P_not_eq_self ScalI1P_mul_self ScalI1P_sub_self ScalI1P_sum_self ScalI2P_mul_self ScalI2P_sub_self ScalI2P_sum_self ScalI4P_mul_self ScalI4P_sub_self ScalI4P_sum_self ScalI8P_mul_self ScalI8P_sub_self ScalI8P_sum_self ScalR4P_mul_self ScalR4P_sub_self ScalR4P_sum_self ScalR8P_mul_self ScalR8P_sub_self ScalR8P_sum_self assign_ScalI1P assign_ScalI2P assign_ScalI4P assign_ScalI8P assign_ScalR4P assign_ScalR8P assign_self assignment(=) crossproduct dotproduct face_normal3 face_normal4 init iolen load negative_self normL2 normalize normalized operator(*) operator(+) operator(-) operator(.cross.) operator(.dot.) operator(.ortho.) operator(.paral.) operator(/) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) orthogonal parallel positive_self print save self_div_ScalI1P self_div_ScalI2P self_div_ScalI4P self_div_ScalI8P self_div_ScalR4P self_div_ScalR8P self_div_self self_eq_I1P self_eq_I2P self_eq_I4P self_eq_I8P self_eq_R4P self_eq_R8P self_eq_self self_great_I1P self_great_I2P self_great_I4P self_great_I8P self_great_R4P self_great_R8P self_great_eq_I1P self_great_eq_I2P self_great_eq_I4P self_great_eq_I8P self_great_eq_R4P self_great_eq_R8P self_great_eq_self self_great_self self_low_I1P self_low_I2P self_low_I4P self_low_I8P self_low_R4P self_low_R8P self_low_eq_I1P self_low_eq_I2P self_low_eq_I4P self_low_eq_I8P self_low_eq_R4P self_low_eq_R8P self_low_eq_self self_low_self self_mul_ScalI1P self_mul_ScalI2P self_mul_ScalI4P self_mul_ScalI8P self_mul_ScalR4P self_mul_ScalR8P self_mul_self self_not_eq_I1P self_not_eq_I2P self_not_eq_I4P self_not_eq_I8P self_not_eq_R4P self_not_eq_R8P self_not_eq_self self_sub_ScalI1P self_sub_ScalI2P self_sub_ScalI4P self_sub_ScalI8P self_sub_ScalR4P self_sub_ScalR8P self_sub_self self_sum_ScalI1P self_sum_ScalI2P self_sum_ScalI4P self_sum_ScalI8P self_sum_ScalR4P self_sum_ScalR8P self_sum_self set sq_norm Source Code vector Components Type Visibility Attributes Name Initial real(kind=R_P), public :: x = 0._R_P Cartesian component in x direction. real(kind=R_P), public :: y = 0._R_P Cartesian component in y direction. real(kind=R_P), public :: z = 0._R_P Cartesian component in z direction. Type-Bound Procedures procedure, private, pass(self ) :: I1P_eq_self private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I1P_great_eq_self private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I1P_great_self private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I1P_low_eq_self private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I1P_low_self private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I1P_not_eq_self private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_eq_self private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_great_eq_self private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_great_self private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_low_eq_self private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_low_self private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I2P_not_eq_self private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_eq_self private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_great_eq_self private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_great_self private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_low_eq_self private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_low_self private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I4P_not_eq_self private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_eq_self private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_great_eq_self private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_great_self private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_low_eq_self private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_low_self private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: I8P_not_eq_self private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_eq_self private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_great_eq_self private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_great_self private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_low_eq_self private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_low_self private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R4P_not_eq_self private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_eq_self private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_great_eq_self private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_great_self private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_low_eq_self private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_low_self private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: R8P_not_eq_self private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: ScalI1P_mul_self private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI1P_sub_self private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI1P_sum_self private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI2P_mul_self private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI2P_sub_self private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI2P_sum_self private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI4P_mul_self private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI4P_sub_self private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI4P_sum_self private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI8P_mul_self private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI8P_sub_self private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalI8P_sum_self private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR4P_mul_self private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR4P_sub_self private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR4P_sum_self private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR8P_mul_self private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR8P_sub_self private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: ScalR8P_sum_self private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: assign_ScalI1P private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. procedure, private, pass(self ) :: assign_ScalI2P private elemental subroutine assign_ScalI2P (self, scal) Assignment between a scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. procedure, private, pass(self ) :: assign_ScalI4P private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. procedure, private, pass(self ) :: assign_ScalI8P private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. procedure, private, pass(self ) :: assign_ScalR4P private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. procedure, private, pass(self ) :: assign_ScalR8P private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. procedure, private, pass(self1) :: assign_self private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self1 Left hand side. class( vector ), intent(in) :: self2 Right hand side. generic, public :: assignment(=) => assign_self , assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self1 Left hand side. class( vector ), intent(in) :: self2 Right hand side. private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI2P (self, scal) Assignment between a scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. procedure, private, pass(vec1) :: crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Cross product vector. procedure, private, pass(vec1) :: dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R_P) Dot product. procedure, public :: face_normal3 => face_normal3_self private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. procedure, public :: face_normal4 => face_normal4_self private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. type( vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. procedure, public :: init => init_vector_self private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. procedure, public :: iolen => iolen_vector_self private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. procedure, public :: load => load_vector_self private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, private, pass(self ) :: negative_self private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. procedure, public :: normL2 => normL2_self private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Norm L2. procedure, public :: normalize => normalize_self private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector to be normalized. procedure, public :: normalized => normalized_self private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector to be normalized. Return Value type( vector ) Normalized copy. generic, public :: operator(*) => self_mul_self , ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P , ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. generic, public :: operator(+) => positive_self , self_sum_self , ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P , ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. generic, public :: operator(-) => negative_self , self_sub_self , ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P , ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. generic, public :: operator(.cross.) => crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Cross product vector. generic, public :: operator(.dot.) => dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R_P) Dot product. generic, public :: operator(.ortho.) => orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 orthogonal to vec2. generic, public :: operator(.paral.) => parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 parallel to vec2. generic, public :: operator(/) => self_div_self , self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. generic, public :: operator(/=) => self_not_eq_self , R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P , I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 First selftor. type( vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. generic, public :: operator(<) => self_low_self , R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P , I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. generic, public :: operator(<=) => self_low_eq_self , R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P , I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. generic, public :: operator(==) => self_eq_self , R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P , I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise.\n Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. generic, public :: operator(>) => self_great_self , R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P , I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. generic, public :: operator(>=) => self_great_eq_self , R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self , self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P , I1P_great_eq_self , self_great_eq_I1P private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(vec1) :: orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 orthogonal to vec2. procedure, private, pass(vec1) :: parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 parallel to vec2. procedure, private, pass(self ) :: positive_self private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. procedure, public :: print => print_vector_self private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, public :: save => save_vector_self private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, private, pass(self ) :: self_div_ScalI1P private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_div_ScalI2P private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_div_ScalI4P private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_div_ScalI8P private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_div_ScalR4P private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_div_ScalR8P private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self1) :: self_div_self private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_eq_I1P private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_eq_I2P private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_eq_I4P private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_eq_I8P private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_eq_R4P private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_eq_R8P private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_eq_self private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise.\n Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_I1P private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_I2P private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_I4P private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_I8P private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_R4P private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_R8P private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_I1P private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_I2P private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_I4P private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_I8P private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_R4P private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_great_eq_R8P private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_great_eq_self private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_great_self private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_I1P private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_I2P private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_I4P private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_I8P private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_R4P private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_R8P private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_I1P private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_I2P private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_I4P private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_I8P private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_R4P private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_low_eq_R8P private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_low_eq_self private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_low_self private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_mul_ScalI1P private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_mul_ScalI2P private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_mul_ScalI4P private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_mul_ScalI8P private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_mul_ScalR4P private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_mul_ScalR8P private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self1) :: self_mul_self private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_not_eq_I1P private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_not_eq_I2P private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_not_eq_I4P private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_not_eq_I8P private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_not_eq_R4P private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self ) :: self_not_eq_R8P private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. procedure, private, pass(self1) :: self_not_eq_self private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 First selftor. type( vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. procedure, private, pass(self ) :: self_sub_ScalI1P private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sub_ScalI2P private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sub_ScalI4P private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sub_ScalI8P private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sub_ScalR4P private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sub_ScalR8P private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self1) :: self_sub_self private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalI1P private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalI2P private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalI4P private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalI8P private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalR4P private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self ) :: self_sum_ScalR8P private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. procedure, private, pass(self1) :: self_sum_self private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. procedure, public :: set => set_vector_self private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. real(kind=R_P), intent(in), optional :: x Cartesian component in x direction. real(kind=R_P), intent(in), optional :: y Cartesian component in y direction. real(kind=R_P), intent(in), optional :: z Cartesian component in z direction. procedure, public :: sq_norm => sq_norm_self private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Square of the Norm. Source Code type :: vector !< Vector class. real ( R_P ) :: x = 0._R_P !< Cartesian component in x direction. real ( R_P ) :: y = 0._R_P !< Cartesian component in y direction. real ( R_P ) :: z = 0._R_P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype vector","tags":"","loc":"type/vector.html","title":"vector – VecFor "},{"text":"type, public :: vector_ptr type~~vector_ptr~~InheritsGraph type~vector_ptr vector_ptr type~vector vector type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Pointer of Vector for creating array of pointers of Vector. Variables p Source Code vector_ptr Components Type Visibility Attributes Name Initial type( vector ), public, pointer :: p => null() Source Code type , public :: vector_ptr !< Pointer of Vector for creating array of pointers of Vector. type ( vector ), pointer :: p => null () endtype vector_ptr","tags":"","loc":"type/vector_ptr.html","title":"vector_ptr – VecFor "},{"text":"private elemental function I1P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_eq_self~~CallsGraph proc~i1p_eq_self I1P_eq_self proc~norml2 normL2 proc~i1p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_eq_self Source Code elemental function I1P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I1P_eq_self","tags":"","loc":"proc/i1p_eq_self.html","title":"I1P_eq_self – VecFor"},{"text":"private elemental function I1P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_great_eq_self~~CallsGraph proc~i1p_great_eq_self I1P_great_eq_self proc~norml2 normL2 proc~i1p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_eq_self Source Code elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I1P_great_eq_self","tags":"","loc":"proc/i1p_great_eq_self.html","title":"I1P_great_eq_self – VecFor"},{"text":"private elemental function I1P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_great_self~~CallsGraph proc~i1p_great_self I1P_great_self proc~norml2 normL2 proc~i1p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_self Source Code elemental function I1P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I1P_great_self","tags":"","loc":"proc/i1p_great_self.html","title":"I1P_great_self – VecFor"},{"text":"private elemental function I1P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_low_eq_self~~CallsGraph proc~i1p_low_eq_self I1P_low_eq_self proc~norml2 normL2 proc~i1p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_eq_self Source Code elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I1P_low_eq_self","tags":"","loc":"proc/i1p_low_eq_self.html","title":"I1P_low_eq_self – VecFor"},{"text":"private elemental function I1P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_low_self~~CallsGraph proc~i1p_low_self I1P_low_self proc~norml2 normL2 proc~i1p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_self Source Code elemental function I1P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I1P_low_self","tags":"","loc":"proc/i1p_low_self.html","title":"I1P_low_self – VecFor"},{"text":"private elemental function I1P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i1p_not_eq_self~~CallsGraph proc~i1p_not_eq_self I1P_not_eq_self proc~norml2 normL2 proc~i1p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_not_eq_self Source Code elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I1P_not_eq_self","tags":"","loc":"proc/i1p_not_eq_self.html","title":"I1P_not_eq_self – VecFor"},{"text":"private elemental function I2P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_eq_self~~CallsGraph proc~i2p_eq_self I2P_eq_self proc~norml2 normL2 proc~i2p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_eq_self Source Code elemental function I2P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I2P_eq_self","tags":"","loc":"proc/i2p_eq_self.html","title":"I2P_eq_self – VecFor"},{"text":"private elemental function I2P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_great_eq_self~~CallsGraph proc~i2p_great_eq_self I2P_great_eq_self proc~norml2 normL2 proc~i2p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_eq_self Source Code elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I2P_great_eq_self","tags":"","loc":"proc/i2p_great_eq_self.html","title":"I2P_great_eq_self – VecFor"},{"text":"private elemental function I2P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_great_self~~CallsGraph proc~i2p_great_self I2P_great_self proc~norml2 normL2 proc~i2p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_self Source Code elemental function I2P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I2P_great_self","tags":"","loc":"proc/i2p_great_self.html","title":"I2P_great_self – VecFor"},{"text":"private elemental function I2P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_low_eq_self~~CallsGraph proc~i2p_low_eq_self I2P_low_eq_self proc~norml2 normL2 proc~i2p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_eq_self Source Code elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I2P_low_eq_self","tags":"","loc":"proc/i2p_low_eq_self.html","title":"I2P_low_eq_self – VecFor"},{"text":"private elemental function I2P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_low_self~~CallsGraph proc~i2p_low_self I2P_low_self proc~norml2 normL2 proc~i2p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_self Source Code elemental function I2P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I2P_low_self","tags":"","loc":"proc/i2p_low_self.html","title":"I2P_low_self – VecFor"},{"text":"private elemental function I2P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i2p_not_eq_self~~CallsGraph proc~i2p_not_eq_self I2P_not_eq_self proc~norml2 normL2 proc~i2p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_not_eq_self Source Code elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I2P_not_eq_self","tags":"","loc":"proc/i2p_not_eq_self.html","title":"I2P_not_eq_self – VecFor"},{"text":"private elemental function I4P_eq_self(scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_eq_self~~CallsGraph proc~i4p_eq_self I4P_eq_self proc~norml2 normL2 proc~i4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_eq_self Source Code elemental function I4P_eq_self ( scal , self ) result ( compare ) !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I4P_eq_self","tags":"","loc":"proc/i4p_eq_self.html","title":"I4P_eq_self – VecFor"},{"text":"private elemental function I4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_great_eq_self~~CallsGraph proc~i4p_great_eq_self I4P_great_eq_self proc~norml2 normL2 proc~i4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_eq_self Source Code elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I4P_great_eq_self","tags":"","loc":"proc/i4p_great_eq_self.html","title":"I4P_great_eq_self – VecFor"},{"text":"private elemental function I4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_great_self~~CallsGraph proc~i4p_great_self I4P_great_self proc~norml2 normL2 proc~i4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_self Source Code elemental function I4P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I4P_great_self","tags":"","loc":"proc/i4p_great_self.html","title":"I4P_great_self – VecFor"},{"text":"private elemental function I4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_low_eq_self~~CallsGraph proc~i4p_low_eq_self I4P_low_eq_self proc~norml2 normL2 proc~i4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_eq_self Source Code elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I4P_low_eq_self","tags":"","loc":"proc/i4p_low_eq_self.html","title":"I4P_low_eq_self – VecFor"},{"text":"private elemental function I4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_low_self~~CallsGraph proc~i4p_low_self I4P_low_self proc~norml2 normL2 proc~i4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_self Source Code elemental function I4P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I4P_low_self","tags":"","loc":"proc/i4p_low_self.html","title":"I4P_low_self – VecFor"},{"text":"private elemental function I4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i4p_not_eq_self~~CallsGraph proc~i4p_not_eq_self I4P_not_eq_self proc~norml2 normL2 proc~i4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_not_eq_self Source Code elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I4P_not_eq_self","tags":"","loc":"proc/i4p_not_eq_self.html","title":"I4P_not_eq_self – VecFor"},{"text":"private elemental function I8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_eq_self~~CallsGraph proc~i8p_eq_self I8P_eq_self proc~norml2 normL2 proc~i8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_eq_self Source Code elemental function I8P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction I8P_eq_self","tags":"","loc":"proc/i8p_eq_self.html","title":"I8P_eq_self – VecFor"},{"text":"private elemental function I8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_great_eq_self~~CallsGraph proc~i8p_great_eq_self I8P_great_eq_self proc~norml2 normL2 proc~i8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_eq_self Source Code elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction I8P_great_eq_self","tags":"","loc":"proc/i8p_great_eq_self.html","title":"I8P_great_eq_self – VecFor"},{"text":"private elemental function I8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_great_self~~CallsGraph proc~i8p_great_self I8P_great_self proc~norml2 normL2 proc~i8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_self Source Code elemental function I8P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction I8P_great_self","tags":"","loc":"proc/i8p_great_self.html","title":"I8P_great_self – VecFor"},{"text":"private elemental function I8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_low_eq_self~~CallsGraph proc~i8p_low_eq_self I8P_low_eq_self proc~norml2 normL2 proc~i8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_eq_self Source Code elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction I8P_low_eq_self","tags":"","loc":"proc/i8p_low_eq_self.html","title":"I8P_low_eq_self – VecFor"},{"text":"private elemental function I8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_low_self~~CallsGraph proc~i8p_low_self I8P_low_self proc~norml2 normL2 proc~i8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_self Source Code elemental function I8P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction I8P_low_self","tags":"","loc":"proc/i8p_low_self.html","title":"I8P_low_self – VecFor"},{"text":"private elemental function I8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~i8p_not_eq_self~~CallsGraph proc~i8p_not_eq_self I8P_not_eq_self proc~norml2 normL2 proc~i8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_not_eq_self Source Code elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction I8P_not_eq_self","tags":"","loc":"proc/i8p_not_eq_self.html","title":"I8P_not_eq_self – VecFor"},{"text":"private elemental function R16P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_eq_self~~CallsGraph proc~r16p_eq_self R16P_eq_self proc~norml2 normL2 proc~r16p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_eq_self Source Code elemental function R16P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R16P_eq_self","tags":"","loc":"proc/r16p_eq_self.html","title":"R16P_eq_self – VecFor"},{"text":"private elemental function R16P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_great_eq_self~~CallsGraph proc~r16p_great_eq_self R16P_great_eq_self proc~norml2 normL2 proc~r16p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_eq_self Source Code elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R16P_great_eq_self","tags":"","loc":"proc/r16p_great_eq_self.html","title":"R16P_great_eq_self – VecFor"},{"text":"private elemental function R16P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_great_self~~CallsGraph proc~r16p_great_self R16P_great_self proc~norml2 normL2 proc~r16p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_self Source Code elemental function R16P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R16P_great_self","tags":"","loc":"proc/r16p_great_self.html","title":"R16P_great_self – VecFor"},{"text":"private elemental function R16P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_low_eq_self~~CallsGraph proc~r16p_low_eq_self R16P_low_eq_self proc~norml2 normL2 proc~r16p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_eq_self Source Code elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R16P_low_eq_self","tags":"","loc":"proc/r16p_low_eq_self.html","title":"R16P_low_eq_self – VecFor"},{"text":"private elemental function R16P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_low_self~~CallsGraph proc~r16p_low_self R16P_low_self proc~norml2 normL2 proc~r16p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_self Source Code elemental function R16P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R16P_low_self","tags":"","loc":"proc/r16p_low_self.html","title":"R16P_low_self – VecFor"},{"text":"private elemental function R16P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r16p_not_eq_self~~CallsGraph proc~r16p_not_eq_self R16P_not_eq_self proc~norml2 normL2 proc~r16p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_not_eq_self Source Code elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R16P_not_eq_self","tags":"","loc":"proc/r16p_not_eq_self.html","title":"R16P_not_eq_self – VecFor"},{"text":"private elemental function R4P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_eq_self~~CallsGraph proc~r4p_eq_self R4P_eq_self proc~norml2 normL2 proc~r4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_eq_self Source Code elemental function R4P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R4P_eq_self","tags":"","loc":"proc/r4p_eq_self.html","title":"R4P_eq_self – VecFor"},{"text":"private elemental function R4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_great_eq_self~~CallsGraph proc~r4p_great_eq_self R4P_great_eq_self proc~norml2 normL2 proc~r4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_eq_self Source Code elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R4P_great_eq_self","tags":"","loc":"proc/r4p_great_eq_self.html","title":"R4P_great_eq_self – VecFor"},{"text":"private elemental function R4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_great_self~~CallsGraph proc~r4p_great_self R4P_great_self proc~norml2 normL2 proc~r4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_self Source Code elemental function R4P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R4P_great_self","tags":"","loc":"proc/r4p_great_self.html","title":"R4P_great_self – VecFor"},{"text":"private elemental function R4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_low_eq_self~~CallsGraph proc~r4p_low_eq_self R4P_low_eq_self proc~norml2 normL2 proc~r4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_eq_self Source Code elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R4P_low_eq_self","tags":"","loc":"proc/r4p_low_eq_self.html","title":"R4P_low_eq_self – VecFor"},{"text":"private elemental function R4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_low_self~~CallsGraph proc~r4p_low_self R4P_low_self proc~norml2 normL2 proc~r4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_self Source Code elemental function R4P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R4P_low_self","tags":"","loc":"proc/r4p_low_self.html","title":"R4P_low_self – VecFor"},{"text":"private elemental function R4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r4p_not_eq_self~~CallsGraph proc~r4p_not_eq_self R4P_not_eq_self proc~norml2 normL2 proc~r4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_not_eq_self Source Code elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R4P_not_eq_self","tags":"","loc":"proc/r4p_not_eq_self.html","title":"R4P_not_eq_self – VecFor"},{"text":"private elemental function R8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_eq_self~~CallsGraph proc~r8p_eq_self R8P_eq_self proc~norml2 normL2 proc~r8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_eq_self Source Code elemental function R8P_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction R8P_eq_self","tags":"","loc":"proc/r8p_eq_self.html","title":"R8P_eq_self – VecFor"},{"text":"private elemental function R8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_great_eq_self~~CallsGraph proc~r8p_great_eq_self R8P_great_eq_self proc~norml2 normL2 proc~r8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_eq_self Source Code elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) >= normL2 ( self )) endfunction R8P_great_eq_self","tags":"","loc":"proc/r8p_great_eq_self.html","title":"R8P_great_eq_self – VecFor"},{"text":"private elemental function R8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_great_self~~CallsGraph proc~r8p_great_self R8P_great_self proc~norml2 normL2 proc~r8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_self Source Code elemental function R8P_great_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) > normL2 ( self )) endfunction R8P_great_self","tags":"","loc":"proc/r8p_great_self.html","title":"R8P_great_self – VecFor"},{"text":"private elemental function R8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_low_eq_self~~CallsGraph proc~r8p_low_eq_self R8P_low_eq_self proc~norml2 normL2 proc~r8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_eq_self Source Code elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) <= normL2 ( self )) endfunction R8P_low_eq_self","tags":"","loc":"proc/r8p_low_eq_self.html","title":"R8P_low_eq_self – VecFor"},{"text":"private elemental function R8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_low_self~~CallsGraph proc~r8p_low_self R8P_low_self proc~norml2 normL2 proc~r8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_self Source Code elemental function R8P_low_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) < normL2 ( self )) endfunction R8P_low_self","tags":"","loc":"proc/r8p_low_self.html","title":"R8P_low_self – VecFor"},{"text":"private elemental function R8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. Calls proc~~r8p_not_eq_self~~CallsGraph proc~r8p_not_eq_self R8P_not_eq_self proc~norml2 normL2 proc~r8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_not_eq_self Source Code elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction R8P_not_eq_self","tags":"","loc":"proc/r8p_not_eq_self.html","title":"R8P_not_eq_self – VecFor"},{"text":"private elemental function ScalI1P_mul_self(scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI1P_mul_self Source Code elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I1P) for self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI1P_mul_self","tags":"","loc":"proc/scali1p_mul_self.html","title":"ScalI1P_mul_self – VecFor"},{"text":"private elemental function ScalI1P_sub_self(scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI1P_sub_self Source Code elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I1P) and self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI1P_sub_self","tags":"","loc":"proc/scali1p_sub_self.html","title":"ScalI1P_sub_self – VecFor"},{"text":"private elemental function ScalI1P_sum_self(scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI1P_sum_self Source Code elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I1P) and self. integer ( I1P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI1P_sum_self","tags":"","loc":"proc/scali1p_sum_self.html","title":"ScalI1P_sum_self – VecFor"},{"text":"private elemental function ScalI2P_mul_self(scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI2P_mul_self Source Code elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I2P) for self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI2P_mul_self","tags":"","loc":"proc/scali2p_mul_self.html","title":"ScalI2P_mul_self – VecFor"},{"text":"private elemental function ScalI2P_sub_self(scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI2P_sub_self Source Code elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I2P) and self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI2P_sub_self","tags":"","loc":"proc/scali2p_sub_self.html","title":"ScalI2P_sub_self – VecFor"},{"text":"private elemental function ScalI2P_sum_self(scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI2P_sum_self Source Code elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I2P) and self. integer ( I2P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI2P_sum_self","tags":"","loc":"proc/scali2p_sum_self.html","title":"ScalI2P_sum_self – VecFor"},{"text":"private elemental function ScalI4P_mul_self(scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI4P_mul_self Source Code elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I4P) for self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI4P_mul_self","tags":"","loc":"proc/scali4p_mul_self.html","title":"ScalI4P_mul_self – VecFor"},{"text":"private elemental function ScalI4P_sub_self(scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI4P_sub_self Source Code elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I4P) and self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI4P_sub_self","tags":"","loc":"proc/scali4p_sub_self.html","title":"ScalI4P_sub_self – VecFor"},{"text":"private elemental function ScalI4P_sum_self(scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI4P_sum_self Source Code elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I4P) and self. integer ( I4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI4P_sum_self","tags":"","loc":"proc/scali4p_sum_self.html","title":"ScalI4P_sum_self – VecFor"},{"text":"private elemental function ScalI8P_mul_self(scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI8P_mul_self Source Code elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (integer I8P) for self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalI8P_mul_self","tags":"","loc":"proc/scali8p_mul_self.html","title":"ScalI8P_mul_self – VecFor"},{"text":"private elemental function ScalI8P_sub_self(scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI8P_sub_self Source Code elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (integer I8P) and self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalI8P_sub_self","tags":"","loc":"proc/scali8p_sub_self.html","title":"ScalI8P_sub_self – VecFor"},{"text":"private elemental function ScalI8P_sum_self(scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalI8P_sum_self Source Code elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (integer I8P) and self. integer ( I8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalI8P_sum_self","tags":"","loc":"proc/scali8p_sum_self.html","title":"ScalI8P_sum_self – VecFor"},{"text":"private elemental function ScalR16P_mul_self(scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR16P_mul_self Source Code elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R16P) for self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR16P_mul_self","tags":"","loc":"proc/scalr16p_mul_self.html","title":"ScalR16P_mul_self – VecFor"},{"text":"private elemental function ScalR16P_sub_self(scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR16P_sub_self Source Code elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R16P) and self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR16P_sub_self","tags":"","loc":"proc/scalr16p_sub_self.html","title":"ScalR16P_sub_self – VecFor"},{"text":"private elemental function ScalR16P_sum_self(scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR16P_sum_self Source Code elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R16P) and self. real ( R16P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR16P_sum_self","tags":"","loc":"proc/scalr16p_sum_self.html","title":"ScalR16P_sum_self – VecFor"},{"text":"private elemental function ScalR4P_mul_self(scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR4P_mul_self Source Code elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R4P) for self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR4P_mul_self","tags":"","loc":"proc/scalr4p_mul_self.html","title":"ScalR4P_mul_self – VecFor"},{"text":"private elemental function ScalR4P_sub_self(scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR4P_sub_self Source Code elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R4P) and self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR4P_sub_self","tags":"","loc":"proc/scalr4p_sub_self.html","title":"ScalR4P_sub_self – VecFor"},{"text":"private elemental function ScalR4P_sum_self(scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR4P_sum_self Source Code elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R4P) and self. real ( R4P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR4P_sum_self","tags":"","loc":"proc/scalr4p_sum_self.html","title":"ScalR4P_sum_self – VecFor"},{"text":"private elemental function ScalR8P_mul_self(scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR8P_mul_self Source Code elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !< Multiply scalar (real R8P) for self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction ScalR8P_mul_self","tags":"","loc":"proc/scalr8p_mul_self.html","title":"ScalR8P_mul_self – VecFor"},{"text":"private elemental function ScalR8P_sub_self(scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR8P_sub_self Source Code elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !< Subtract scalar (real R8P) and self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = real ( scal , R_P ) - self % x sub % y = real ( scal , R_P ) - self % y sub % z = real ( scal , R_P ) - self % z endfunction ScalR8P_sub_self","tags":"","loc":"proc/scalr8p_sub_self.html","title":"ScalR8P_sub_self – VecFor"},{"text":"private elemental function ScalR8P_sum_self(scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. Source Code ScalR8P_sum_self Source Code elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !< Sum scalar (real R8P) and self. real ( R8P ), intent ( in ) :: scal !< Left hand side. class ( vector ), intent ( in ) :: self !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction ScalR8P_sum_self","tags":"","loc":"proc/scalr8p_sum_self.html","title":"ScalR8P_sum_self – VecFor"},{"text":"private elemental function crossproduct(vec1, vec2) result(cross) Compute the cross product of 2 vectors.  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i +\n           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j +\n           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Cross product vector. Source Code crossproduct Source Code elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: cross !< Cross product vector. cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) endfunction crossproduct","tags":"","loc":"proc/crossproduct.html","title":"crossproduct – VecFor"},{"text":"private elemental function dotproduct(vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors.  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2 \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R_P) Dot product. Source Code dotproduct Source Code elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. real ( R_P ) :: dot !< Dot product. dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) endfunction dotproduct","tags":"","loc":"proc/dotproduct.html","title":"dotproduct – VecFor"},{"text":"public elemental function face_normal3(pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable 'norm' is passed (with any value). Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( vector ) Face normal. Calls proc~~face_normal3~~CallsGraph proc~face_normal3 face_normal3 proc~normalize normalize proc~face_normal3->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~face_normal3~~CalledByGraph proc~face_normal3 face_normal3 program~simple simple program~simple->proc~face_normal3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3 Source Code elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: fnormal !< Face normal. type ( vector ) :: s12 !< Face 1-2 diagonals. type ( vector ) :: s13 !< Face 1-3 diagonals. s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R_P * ( s12 . cross . s13 ) endif endfunction face_normal3","tags":"","loc":"proc/face_normal3.html","title":"face_normal3 – VecFor"},{"text":"public elemental function face_normal4(pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. type( vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( vector ) Face normal. Calls proc~~face_normal4~~CallsGraph proc~face_normal4 face_normal4 proc~normalize normalize proc~face_normal4->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~face_normal4~~CalledByGraph proc~face_normal4 face_normal4 program~simple simple program~simple->proc~face_normal4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4 Source Code elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. type ( vector ), intent ( in ) :: pt4 !< Fourth face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: fnormal !< Face normal. type ( vector ) :: d13 !< Face 1-3 diagonal. type ( vector ) :: d24 !< Face 2-4 diagonal. d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R_P * ( d13 . cross . d24 ) endif endfunction face_normal4","tags":"","loc":"proc/face_normal4.html","title":"face_normal4 – VecFor"},{"text":"private function iolen_vector_self(vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. Source Code iolen_vector_self Source Code function iolen_vector_self ( vec ) result ( iolen ) !< Compute IO length. class ( vector ), intent ( in ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. inquire ( iolength = iolen ) vec % x , vec % y , vec % z endfunction iolen_vector_self","tags":"","loc":"proc/iolen_vector_self.html","title":"iolen_vector_self – VecFor"},{"text":"private elemental function negative_self(self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. Source Code negative_self Source Code elemental function negative_self ( self ) result ( neg ) !< Applay unary - to a self. class ( vector ), intent ( in ) :: self !< Unary object. type ( vector ) :: neg !< Operator result. neg % x = - self % x neg % y = - self % y neg % z = - self % z endfunction negative_self","tags":"","loc":"proc/negative_self.html","title":"negative_self – VecFor"},{"text":"public elemental function normL2(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Norm L2. Called By proc~~norml2~~CalledByGraph proc~norml2 normL2 proc~r8p_great_eq_self R8P_great_eq_self proc~r8p_great_eq_self->proc~norml2 proc~i4p_not_eq_self I4P_not_eq_self proc~i4p_not_eq_self->proc~norml2 proc~i1p_eq_self I1P_eq_self proc~i1p_eq_self->proc~norml2 proc~i4p_low_eq_self I4P_low_eq_self proc~i4p_low_eq_self->proc~norml2 proc~normalized_self normalized_self proc~normalized_self->proc~norml2 proc~i2p_low_eq_self I2P_low_eq_self proc~i2p_low_eq_self->proc~norml2 proc~i4p_great_eq_self I4P_great_eq_self proc~i4p_great_eq_self->proc~norml2 proc~self_great_eq_i2p self_great_eq_I2P proc~self_great_eq_i2p->proc~norml2 proc~i1p_great_eq_self I1P_great_eq_self proc~i1p_great_eq_self->proc~norml2 proc~self_not_eq_i2p self_not_eq_I2P proc~self_not_eq_i2p->proc~norml2 proc~self_not_eq_r8p self_not_eq_R8P proc~self_not_eq_r8p->proc~norml2 proc~i4p_great_self I4P_great_self proc~i4p_great_self->proc~norml2 proc~parallel parallel proc~parallel->proc~norml2 proc~normalize normalize proc~parallel->proc~normalize proc~self_not_eq_i8p self_not_eq_I8P proc~self_not_eq_i8p->proc~norml2 proc~self_not_eq_r4p self_not_eq_R4P proc~self_not_eq_r4p->proc~norml2 proc~self_not_eq_r16p self_not_eq_R16P proc~self_not_eq_r16p->proc~norml2 proc~i4p_eq_self I4P_eq_self proc~i4p_eq_self->proc~norml2 proc~i1p_low_eq_self I1P_low_eq_self proc~i1p_low_eq_self->proc~norml2 proc~r16p_great_self R16P_great_self proc~r16p_great_self->proc~norml2 program~simple simple program~simple->proc~norml2 proc~face_normal3 face_normal3 program~simple->proc~face_normal3 proc~face_normal4 face_normal4 program~simple->proc~face_normal4 proc~i1p_great_self I1P_great_self proc~i1p_great_self->proc~norml2 proc~i2p_low_self I2P_low_self proc~i2p_low_self->proc~norml2 proc~self_great_eq_i1p self_great_eq_I1P proc~self_great_eq_i1p->proc~norml2 proc~self_eq_i1p self_eq_I1P proc~self_eq_i1p->proc~norml2 proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~norml2 proc~self_not_eq_self->proc~normalize proc~i2p_not_eq_self I2P_not_eq_self proc~i2p_not_eq_self->proc~norml2 proc~r8p_not_eq_self R8P_not_eq_self proc~r8p_not_eq_self->proc~norml2 proc~i8p_eq_self I8P_eq_self proc~i8p_eq_self->proc~norml2 proc~i8p_great_self I8P_great_self proc~i8p_great_self->proc~norml2 proc~i4p_low_self I4P_low_self proc~i4p_low_self->proc~norml2 proc~self_not_eq_i1p self_not_eq_I1P proc~self_not_eq_i1p->proc~norml2 proc~i8p_low_self I8P_low_self proc~i8p_low_self->proc~norml2 proc~self_eq_self self_eq_self proc~self_eq_self->proc~norml2 proc~self_eq_self->proc~normalize proc~self_not_eq_i4p self_not_eq_I4P proc~self_not_eq_i4p->proc~norml2 proc~i8p_great_eq_self I8P_great_eq_self proc~i8p_great_eq_self->proc~norml2 proc~i2p_great_eq_self I2P_great_eq_self proc~i2p_great_eq_self->proc~norml2 proc~r4p_great_self R4P_great_self proc~r4p_great_self->proc~norml2 proc~r16p_great_eq_self R16P_great_eq_self proc~r16p_great_eq_self->proc~norml2 proc~self_eq_r4p self_eq_R4P proc~self_eq_r4p->proc~norml2 proc~self_great_eq_i4p self_great_eq_I4P proc~self_great_eq_i4p->proc~norml2 proc~i8p_not_eq_self I8P_not_eq_self proc~i8p_not_eq_self->proc~norml2 proc~self_low_eq_r8p self_low_eq_R8P proc~self_low_eq_r8p->proc~norml2 proc~self_eq_r8p self_eq_R8P proc~self_eq_r8p->proc~norml2 proc~r4p_not_eq_self R4P_not_eq_self proc~r4p_not_eq_self->proc~norml2 proc~self_low_eq_i1p self_low_eq_I1P proc~self_low_eq_i1p->proc~norml2 proc~self_low_eq_self self_low_eq_self proc~self_low_eq_self->proc~norml2 proc~self_low_r8p self_low_R8P proc~self_low_r8p->proc~norml2 proc~r16p_low_eq_self R16P_low_eq_self proc~r16p_low_eq_self->proc~norml2 proc~self_eq_i4p self_eq_I4P proc~self_eq_i4p->proc~norml2 proc~r8p_low_eq_self R8P_low_eq_self proc~r8p_low_eq_self->proc~norml2 proc~self_low_self self_low_self proc~self_low_self->proc~norml2 proc~self_eq_i8p self_eq_I8P proc~self_eq_i8p->proc~norml2 proc~r16p_eq_self R16P_eq_self proc~r16p_eq_self->proc~norml2 proc~self_low_eq_i4p self_low_eq_I4P proc~self_low_eq_i4p->proc~norml2 proc~self_low_eq_r16p self_low_eq_R16P proc~self_low_eq_r16p->proc~norml2 proc~self_low_i8p self_low_I8P proc~self_low_i8p->proc~norml2 proc~r8p_eq_self R8P_eq_self proc~r8p_eq_self->proc~norml2 proc~self_eq_i2p self_eq_I2P proc~self_eq_i2p->proc~norml2 proc~self_low_eq_i8p self_low_eq_I8P proc~self_low_eq_i8p->proc~norml2 proc~self_low_eq_r4p self_low_eq_R4P proc~self_low_eq_r4p->proc~norml2 proc~self_low_r16p self_low_R16P proc~self_low_r16p->proc~norml2 proc~self_low_r4p self_low_R4P proc~self_low_r4p->proc~norml2 proc~r4p_great_eq_self R4P_great_eq_self proc~r4p_great_eq_self->proc~norml2 proc~r16p_low_self R16P_low_self proc~r16p_low_self->proc~norml2 proc~i2p_eq_self I2P_eq_self proc~i2p_eq_self->proc~norml2 proc~r4p_eq_self R4P_eq_self proc~r4p_eq_self->proc~norml2 proc~i1p_not_eq_self I1P_not_eq_self proc~i1p_not_eq_self->proc~norml2 proc~self_low_eq_i2p self_low_eq_I2P proc~self_low_eq_i2p->proc~norml2 proc~r8p_great_self R8P_great_self proc~r8p_great_self->proc~norml2 proc~r4p_low_eq_self R4P_low_eq_self proc~r4p_low_eq_self->proc~norml2 proc~r4p_low_self R4P_low_self proc~r4p_low_self->proc~norml2 proc~normalize->proc~norml2 proc~r8p_low_self R8P_low_self proc~r8p_low_self->proc~norml2 proc~self_great_i4p self_great_I4P proc~self_great_i4p->proc~norml2 proc~self_low_i1p self_low_I1P proc~self_low_i1p->proc~norml2 proc~i1p_low_self I1P_low_self proc~i1p_low_self->proc~norml2 proc~self_low_i2p self_low_I2P proc~self_low_i2p->proc~norml2 proc~self_great_r8p self_great_R8P proc~self_great_r8p->proc~norml2 proc~self_great_self self_great_self proc~self_great_self->proc~norml2 proc~normalize_self normalize_self proc~normalize_self->proc~norml2 proc~self_low_i4p self_low_I4P proc~self_low_i4p->proc~norml2 proc~self_great_eq_i8p self_great_eq_I8P proc~self_great_eq_i8p->proc~norml2 proc~self_great_r16p self_great_R16P proc~self_great_r16p->proc~norml2 proc~self_great_eq_self self_great_eq_self proc~self_great_eq_self->proc~norml2 proc~i2p_great_self I2P_great_self proc~i2p_great_self->proc~norml2 proc~i8p_low_eq_self I8P_low_eq_self proc~i8p_low_eq_self->proc~norml2 proc~self_great_i1p self_great_I1P proc~self_great_i1p->proc~norml2 proc~self_great_eq_r8p self_great_eq_R8P proc~self_great_eq_r8p->proc~norml2 proc~self_great_eq_r4p self_great_eq_R4P proc~self_great_eq_r4p->proc~norml2 proc~self_great_i8p self_great_I8P proc~self_great_i8p->proc~norml2 proc~self_eq_r16p self_eq_R16P proc~self_eq_r16p->proc~norml2 proc~self_great_i2p self_great_I2P proc~self_great_i2p->proc~norml2 proc~self_great_r4p self_great_R4P proc~self_great_r4p->proc~norml2 proc~self_great_eq_r16p self_great_eq_R16P proc~self_great_eq_r16p->proc~norml2 proc~r16p_not_eq_self R16P_not_eq_self proc~r16p_not_eq_self->proc~norml2 proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize proc~face_normal3->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~face_normal4->proc~normalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normL2 Source Code elemental function normL2 ( vec ) result ( norm ) !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . type ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: norm !< Norm L2. norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) endfunction normL2","tags":"","loc":"proc/norml2.html","title":"normL2 – VecFor"},{"text":"private elemental function normL2_self(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Norm L2. Source Code normL2_self Source Code elemental function normL2_self ( vec ) result ( norm ) !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . class ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: norm !< Norm L2. norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) endfunction normL2_self","tags":"","loc":"proc/norml2_self.html","title":"normL2_self – VecFor"},{"text":"public elemental function normalize(vec) result(norm) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the\n normalization value is set to normL2(vec)+smallR_P. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector to be normalized. Return Value type( vector ) Vector normalized. Calls proc~~normalize~~CallsGraph proc~normalize normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~normalize~~CalledByGraph proc~normalize normalize proc~parallel parallel proc~parallel->proc~normalize proc~self_eq_self self_eq_self proc~self_eq_self->proc~normalize proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~normalize proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize proc~face_normal3 face_normal3 proc~face_normal3->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~face_normal4 face_normal4 proc~face_normal4->proc~normalize program~simple simple program~simple->proc~face_normal3 program~simple->proc~face_normal4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize Source Code elemental function normalize ( vec ) result ( norm ) !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. type ( vector ), intent ( in ) :: vec !< Vector to be normalized. type ( vector ) :: norm !< Vector normalized. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm endfunction normalize","tags":"","loc":"proc/normalize.html","title":"normalize – VecFor"},{"text":"private elemental function normalized_self(vec) result(norm) Get a normalized copy of a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the\n normalization value is set to normL2(vec)+smallR_P. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector to be normalized. Return Value type( vector ) Normalized copy. Calls proc~~normalized_self~~CallsGraph proc~normalized_self normalized_self proc~norml2 normL2 proc~normalized_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalized_self Source Code elemental function normalized_self ( vec ) result ( norm ) !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. class ( vector ), intent ( in ) :: vec !< Vector to be normalized. type ( vector ) :: norm !< Normalized copy. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm endfunction normalized_self","tags":"","loc":"proc/normalized_self.html","title":"normalized_self – VecFor"},{"text":"private elemental function orthogonal(vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 orthogonal to vec2. Source Code orthogonal Source Code elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !< Compute the component of vec1 orthogonal to vec2. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: ortho !< Component of of vec1 orthogonal to vec2. ortho = vec1 - ( vec1 . paral . vec2 ) endfunction orthogonal","tags":"","loc":"proc/orthogonal.html","title":"orthogonal – VecFor"},{"text":"private elemental function parallel(vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 parallel to vec2. Calls proc~~parallel~~CallsGraph proc~parallel parallel proc~norml2 normL2 proc~parallel->proc~norml2 proc~normalize normalize proc~parallel->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parallel Source Code elemental function parallel ( vec1 , vec2 ) result ( paral ) !> Compute the component of vec1 parallel to vec2. class ( vector ), intent ( in ) :: vec1 !< First vector. type ( vector ), intent ( in ) :: vec2 !< Second vector. type ( vector ) :: paral !< Component of of vec1 parallel to vec2. paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) endfunction parallel","tags":"","loc":"proc/parallel.html","title":"parallel – VecFor"},{"text":"private elemental function positive_self(self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. Source Code positive_self Source Code elemental function positive_self ( self ) result ( pos ) !< Applay unary + to a self. class ( vector ), intent ( in ) :: self !< Unary object. type ( vector ) :: pos !< Operator result. pos % x = + self % x pos % y = + self % y pos % z = + self % z endfunction positive_self","tags":"","loc":"proc/positive_self.html","title":"positive_self – VecFor"},{"text":"private elemental function self_div_ScalI1P(self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalI1P Source Code elemental function self_div_ScalI1P ( self , scal ) result ( div ) !< Divide self for scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI1P","tags":"","loc":"proc/self_div_scali1p.html","title":"self_div_ScalI1P – VecFor"},{"text":"private elemental function self_div_ScalI2P(self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalI2P Source Code elemental function self_div_ScalI2P ( self , scal ) result ( div ) !< Divide self for scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI2P","tags":"","loc":"proc/self_div_scali2p.html","title":"self_div_ScalI2P – VecFor"},{"text":"private elemental function self_div_ScalI4P(self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalI4P Source Code elemental function self_div_ScalI4P ( self , scal ) result ( div ) !< Divide self for scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI4P","tags":"","loc":"proc/self_div_scali4p.html","title":"self_div_ScalI4P – VecFor"},{"text":"private elemental function self_div_ScalI8P(self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalI8P Source Code elemental function self_div_ScalI8P ( self , scal ) result ( div ) !< Divide self for scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalI8P","tags":"","loc":"proc/self_div_scali8p.html","title":"self_div_ScalI8P – VecFor"},{"text":"private elemental function self_div_ScalR16P(self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalR16P Source Code elemental function self_div_ScalR16P ( self , scal ) result ( div ) !< Divide self for scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR16P","tags":"","loc":"proc/self_div_scalr16p.html","title":"self_div_ScalR16P – VecFor"},{"text":"private elemental function self_div_ScalR4P(self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalR4P Source Code elemental function self_div_ScalR4P ( self , scal ) result ( div ) !< Divide self for scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR4P","tags":"","loc":"proc/self_div_scalr4p.html","title":"self_div_ScalR4P – VecFor"},{"text":"private elemental function self_div_ScalR8P(self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_div_ScalR8P Source Code elemental function self_div_ScalR8P ( self , scal ) result ( div ) !< Divide self for scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self % x / real ( scal , R_P ) div % y = self % y / real ( scal , R_P ) div % z = self % z / real ( scal , R_P ) endfunction self_div_ScalR8P","tags":"","loc":"proc/self_div_scalr8p.html","title":"self_div_ScalR8P – VecFor"},{"text":"private elemental function self_div_self(self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. Source Code self_div_self Source Code elemental function self_div_self ( self1 , self2 ) result ( div ) !< Divide self for self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: div !< Operator result. div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z endfunction self_div_self","tags":"","loc":"proc/self_div_self.html","title":"self_div_self – VecFor"},{"text":"private elemental function self_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_i1p~~CallsGraph proc~self_eq_i1p self_eq_I1P proc~norml2 normL2 proc~self_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I1P Source Code elemental function self_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I1P","tags":"","loc":"proc/self_eq_i1p.html","title":"self_eq_I1P – VecFor"},{"text":"private elemental function self_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_i2p~~CallsGraph proc~self_eq_i2p self_eq_I2P proc~norml2 normL2 proc~self_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I2P Source Code elemental function self_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I2P","tags":"","loc":"proc/self_eq_i2p.html","title":"self_eq_I2P – VecFor"},{"text":"private elemental function self_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_i4p~~CallsGraph proc~self_eq_i4p self_eq_I4P proc~norml2 normL2 proc~self_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I4P Source Code elemental function self_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I4P","tags":"","loc":"proc/self_eq_i4p.html","title":"self_eq_I4P – VecFor"},{"text":"private elemental function self_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_i8p~~CallsGraph proc~self_eq_i8p self_eq_I8P proc~norml2 normL2 proc~self_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I8P Source Code elemental function self_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_I8P","tags":"","loc":"proc/self_eq_i8p.html","title":"self_eq_I8P – VecFor"},{"text":"private elemental function self_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_r16p~~CallsGraph proc~self_eq_r16p self_eq_R16P proc~norml2 normL2 proc~self_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R16P Source Code elemental function self_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R16P","tags":"","loc":"proc/self_eq_r16p.html","title":"self_eq_R16P – VecFor"},{"text":"private elemental function self_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_r4p~~CallsGraph proc~self_eq_r4p self_eq_R4P proc~norml2 normL2 proc~self_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R4P Source Code elemental function self_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R4P","tags":"","loc":"proc/self_eq_r4p.html","title":"self_eq_R4P – VecFor"},{"text":"private elemental function self_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_eq_r8p~~CallsGraph proc~self_eq_r8p self_eq_R8P proc~norml2 normL2 proc~self_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R8P Source Code elemental function self_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) == real ( scal , R_P )) endfunction self_eq_R8P","tags":"","loc":"proc/self_eq_r8p.html","title":"self_eq_R8P – VecFor"},{"text":"private elemental function self_eq_self(self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise.\n Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. Calls proc~~self_eq_self~~CallsGraph proc~self_eq_self self_eq_self proc~norml2 normL2 proc~self_eq_self->proc~norml2 proc~normalize normalize proc~self_eq_self->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_self Source Code elemental function self_eq_self ( self1 , self2 ) result ( compare ) !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. type ( vector ) :: n1 !< Normalizations of self1. type ( vector ) :: n2 !< Normalizations of self2. compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif endfunction self_eq_self","tags":"","loc":"proc/self_eq_self.html","title":"self_eq_self – VecFor"},{"text":"private elemental function self_great_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_i1p~~CallsGraph proc~self_great_i1p self_great_I1P proc~norml2 normL2 proc~self_great_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I1P Source Code elemental function self_great_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I1P","tags":"","loc":"proc/self_great_i1p.html","title":"self_great_I1P – VecFor"},{"text":"private elemental function self_great_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_i2p~~CallsGraph proc~self_great_i2p self_great_I2P proc~norml2 normL2 proc~self_great_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I2P Source Code elemental function self_great_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I2P","tags":"","loc":"proc/self_great_i2p.html","title":"self_great_I2P – VecFor"},{"text":"private elemental function self_great_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_i4p~~CallsGraph proc~self_great_i4p self_great_I4P proc~norml2 normL2 proc~self_great_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I4P Source Code elemental function self_great_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I4P","tags":"","loc":"proc/self_great_i4p.html","title":"self_great_I4P – VecFor"},{"text":"private elemental function self_great_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_i8p~~CallsGraph proc~self_great_i8p self_great_I8P proc~norml2 normL2 proc~self_great_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I8P Source Code elemental function self_great_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_I8P","tags":"","loc":"proc/self_great_i8p.html","title":"self_great_I8P – VecFor"},{"text":"private elemental function self_great_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_r16p~~CallsGraph proc~self_great_r16p self_great_R16P proc~norml2 normL2 proc~self_great_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R16P Source Code elemental function self_great_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R16P","tags":"","loc":"proc/self_great_r16p.html","title":"self_great_R16P – VecFor"},{"text":"private elemental function self_great_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_r4p~~CallsGraph proc~self_great_r4p self_great_R4P proc~norml2 normL2 proc~self_great_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R4P Source Code elemental function self_great_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R4P","tags":"","loc":"proc/self_great_r4p.html","title":"self_great_R4P – VecFor"},{"text":"private elemental function self_great_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_r8p~~CallsGraph proc~self_great_r8p self_great_R8P proc~norml2 normL2 proc~self_great_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R8P Source Code elemental function self_great_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) > real ( scal , R_P )) endfunction self_great_R8P","tags":"","loc":"proc/self_great_r8p.html","title":"self_great_R8P – VecFor"},{"text":"private elemental function self_great_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_i1p~~CallsGraph proc~self_great_eq_i1p self_great_eq_I1P proc~norml2 normL2 proc~self_great_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I1P Source Code elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I1P","tags":"","loc":"proc/self_great_eq_i1p.html","title":"self_great_eq_I1P – VecFor"},{"text":"private elemental function self_great_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_i2p~~CallsGraph proc~self_great_eq_i2p self_great_eq_I2P proc~norml2 normL2 proc~self_great_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I2P Source Code elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I2P","tags":"","loc":"proc/self_great_eq_i2p.html","title":"self_great_eq_I2P – VecFor"},{"text":"private elemental function self_great_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_i4p~~CallsGraph proc~self_great_eq_i4p self_great_eq_I4P proc~norml2 normL2 proc~self_great_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I4P Source Code elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I4P","tags":"","loc":"proc/self_great_eq_i4p.html","title":"self_great_eq_I4P – VecFor"},{"text":"private elemental function self_great_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_i8p~~CallsGraph proc~self_great_eq_i8p self_great_eq_I8P proc~norml2 normL2 proc~self_great_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I8P Source Code elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_I8P","tags":"","loc":"proc/self_great_eq_i8p.html","title":"self_great_eq_I8P – VecFor"},{"text":"private elemental function self_great_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_r16p~~CallsGraph proc~self_great_eq_r16p self_great_eq_R16P proc~norml2 normL2 proc~self_great_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R16P Source Code elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R16P","tags":"","loc":"proc/self_great_eq_r16p.html","title":"self_great_eq_R16P – VecFor"},{"text":"private elemental function self_great_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_r4p~~CallsGraph proc~self_great_eq_r4p self_great_eq_R4P proc~norml2 normL2 proc~self_great_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R4P Source Code elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R4P","tags":"","loc":"proc/self_great_eq_r4p.html","title":"self_great_eq_R4P – VecFor"},{"text":"private elemental function self_great_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_r8p~~CallsGraph proc~self_great_eq_r8p self_great_eq_R8P proc~norml2 normL2 proc~self_great_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R8P Source Code elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) >= real ( scal , R_P )) endfunction self_great_eq_R8P","tags":"","loc":"proc/self_great_eq_r8p.html","title":"self_great_eq_R8P – VecFor"},{"text":"private elemental function self_great_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. Calls proc~~self_great_eq_self~~CallsGraph proc~self_great_eq_self self_great_eq_self proc~norml2 normL2 proc~self_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_self Source Code elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) >= normL2 ( self2 )) endfunction self_great_eq_self","tags":"","loc":"proc/self_great_eq_self.html","title":"self_great_eq_self – VecFor"},{"text":"private elemental function self_great_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. Calls proc~~self_great_self~~CallsGraph proc~self_great_self self_great_self proc~norml2 normL2 proc~self_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_self Source Code elemental function self_great_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) > normL2 ( self2 )) endfunction self_great_self","tags":"","loc":"proc/self_great_self.html","title":"self_great_self – VecFor"},{"text":"private elemental function self_low_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_i1p~~CallsGraph proc~self_low_i1p self_low_I1P proc~norml2 normL2 proc~self_low_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I1P Source Code elemental function self_low_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I1P","tags":"","loc":"proc/self_low_i1p.html","title":"self_low_I1P – VecFor"},{"text":"private elemental function self_low_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_i2p~~CallsGraph proc~self_low_i2p self_low_I2P proc~norml2 normL2 proc~self_low_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I2P Source Code elemental function self_low_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I2P","tags":"","loc":"proc/self_low_i2p.html","title":"self_low_I2P – VecFor"},{"text":"private elemental function self_low_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_i4p~~CallsGraph proc~self_low_i4p self_low_I4P proc~norml2 normL2 proc~self_low_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I4P Source Code elemental function self_low_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I4P","tags":"","loc":"proc/self_low_i4p.html","title":"self_low_I4P – VecFor"},{"text":"private elemental function self_low_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_i8p~~CallsGraph proc~self_low_i8p self_low_I8P proc~norml2 normL2 proc~self_low_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I8P Source Code elemental function self_low_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_I8P","tags":"","loc":"proc/self_low_i8p.html","title":"self_low_I8P – VecFor"},{"text":"private elemental function self_low_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_r16p~~CallsGraph proc~self_low_r16p self_low_R16P proc~norml2 normL2 proc~self_low_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R16P Source Code elemental function self_low_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R16P","tags":"","loc":"proc/self_low_r16p.html","title":"self_low_R16P – VecFor"},{"text":"private elemental function self_low_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_r4p~~CallsGraph proc~self_low_r4p self_low_R4P proc~norml2 normL2 proc~self_low_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R4P Source Code elemental function self_low_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R4P","tags":"","loc":"proc/self_low_r4p.html","title":"self_low_R4P – VecFor"},{"text":"private elemental function self_low_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_r8p~~CallsGraph proc~self_low_r8p self_low_R8P proc~norml2 normL2 proc~self_low_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R8P Source Code elemental function self_low_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) < real ( scal , R_P )) endfunction self_low_R8P","tags":"","loc":"proc/self_low_r8p.html","title":"self_low_R8P – VecFor"},{"text":"private elemental function self_low_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_i1p~~CallsGraph proc~self_low_eq_i1p self_low_eq_I1P proc~norml2 normL2 proc~self_low_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I1P Source Code elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I1P","tags":"","loc":"proc/self_low_eq_i1p.html","title":"self_low_eq_I1P – VecFor"},{"text":"private elemental function self_low_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_i2p~~CallsGraph proc~self_low_eq_i2p self_low_eq_I2P proc~norml2 normL2 proc~self_low_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I2P Source Code elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I2P","tags":"","loc":"proc/self_low_eq_i2p.html","title":"self_low_eq_I2P – VecFor"},{"text":"private elemental function self_low_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_i4p~~CallsGraph proc~self_low_eq_i4p self_low_eq_I4P proc~norml2 normL2 proc~self_low_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I4P Source Code elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I4P","tags":"","loc":"proc/self_low_eq_i4p.html","title":"self_low_eq_I4P – VecFor"},{"text":"private elemental function self_low_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_i8p~~CallsGraph proc~self_low_eq_i8p self_low_eq_I8P proc~norml2 normL2 proc~self_low_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I8P Source Code elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_I8P","tags":"","loc":"proc/self_low_eq_i8p.html","title":"self_low_eq_I8P – VecFor"},{"text":"private elemental function self_low_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_r16p~~CallsGraph proc~self_low_eq_r16p self_low_eq_R16P proc~norml2 normL2 proc~self_low_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R16P Source Code elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R16P","tags":"","loc":"proc/self_low_eq_r16p.html","title":"self_low_eq_R16P – VecFor"},{"text":"private elemental function self_low_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_r4p~~CallsGraph proc~self_low_eq_r4p self_low_eq_R4P proc~norml2 normL2 proc~self_low_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R4P Source Code elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R4P","tags":"","loc":"proc/self_low_eq_r4p.html","title":"self_low_eq_R4P – VecFor"},{"text":"private elemental function self_low_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_r8p~~CallsGraph proc~self_low_eq_r8p self_low_eq_R8P proc~norml2 normL2 proc~self_low_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R8P Source Code elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self ) <= real ( scal , R_P )) endfunction self_low_eq_R8P","tags":"","loc":"proc/self_low_eq_r8p.html","title":"self_low_eq_R8P – VecFor"},{"text":"private elemental function self_low_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. Calls proc~~self_low_eq_self~~CallsGraph proc~self_low_eq_self self_low_eq_self proc~norml2 normL2 proc~self_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_self Source Code elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) <= normL2 ( self2 )) endfunction self_low_eq_self","tags":"","loc":"proc/self_low_eq_self.html","title":"self_low_eq_self – VecFor"},{"text":"private elemental function self_low_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. Calls proc~~self_low_self~~CallsGraph proc~self_low_self self_low_self proc~norml2 normL2 proc~self_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_self Source Code elemental function self_low_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. logical :: compare !< Operator result. compare = ( normL2 ( self1 ) < normL2 ( self2 )) endfunction self_low_self","tags":"","loc":"proc/self_low_self.html","title":"self_low_self – VecFor"},{"text":"private elemental function self_mul_ScalI1P(self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalI1P Source Code elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI1P","tags":"","loc":"proc/self_mul_scali1p.html","title":"self_mul_ScalI1P – VecFor"},{"text":"private elemental function self_mul_ScalI2P(self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalI2P Source Code elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI2P","tags":"","loc":"proc/self_mul_scali2p.html","title":"self_mul_ScalI2P – VecFor"},{"text":"private elemental function self_mul_ScalI4P(self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalI4P Source Code elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI4P","tags":"","loc":"proc/self_mul_scali4p.html","title":"self_mul_ScalI4P – VecFor"},{"text":"private elemental function self_mul_ScalI8P(self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalI8P Source Code elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !< Multiply self for scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalI8P","tags":"","loc":"proc/self_mul_scali8p.html","title":"self_mul_ScalI8P – VecFor"},{"text":"private elemental function self_mul_ScalR16P(self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalR16P Source Code elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR16P","tags":"","loc":"proc/self_mul_scalr16p.html","title":"self_mul_ScalR16P – VecFor"},{"text":"private elemental function self_mul_ScalR4P(self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalR4P Source Code elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR4P","tags":"","loc":"proc/self_mul_scalr4p.html","title":"self_mul_ScalR4P – VecFor"},{"text":"private elemental function self_mul_ScalR8P(self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_ScalR8P Source Code elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !< Multiply self for scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = real ( scal , R_P ) * self % x mul % y = real ( scal , R_P ) * self % y mul % z = real ( scal , R_P ) * self % z endfunction self_mul_ScalR8P","tags":"","loc":"proc/self_mul_scalr8p.html","title":"self_mul_ScalR8P – VecFor"},{"text":"private elemental function self_mul_self(self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. Source Code self_mul_self Source Code elemental function self_mul_self ( self1 , self2 ) result ( mul ) !< Multiply (by components) two selfs. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: mul !< Operator result. mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z endfunction self_mul_self","tags":"","loc":"proc/self_mul_self.html","title":"self_mul_self – VecFor"},{"text":"private elemental function self_not_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_i1p~~CallsGraph proc~self_not_eq_i1p self_not_eq_I1P proc~norml2 normL2 proc~self_not_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I1P Source Code elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I1P","tags":"","loc":"proc/self_not_eq_i1p.html","title":"self_not_eq_I1P – VecFor"},{"text":"private elemental function self_not_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_i2p~~CallsGraph proc~self_not_eq_i2p self_not_eq_I2P proc~norml2 normL2 proc~self_not_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I2P Source Code elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I2P","tags":"","loc":"proc/self_not_eq_i2p.html","title":"self_not_eq_I2P – VecFor"},{"text":"private elemental function self_not_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_i4p~~CallsGraph proc~self_not_eq_i4p self_not_eq_I4P proc~norml2 normL2 proc~self_not_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I4P Source Code elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I4P","tags":"","loc":"proc/self_not_eq_i4p.html","title":"self_not_eq_I4P – VecFor"},{"text":"private elemental function self_not_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_i8p~~CallsGraph proc~self_not_eq_i8p self_not_eq_I8P proc~norml2 normL2 proc~self_not_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I8P Source Code elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_I8P","tags":"","loc":"proc/self_not_eq_i8p.html","title":"self_not_eq_I8P – VecFor"},{"text":"private elemental function self_not_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_r16p~~CallsGraph proc~self_not_eq_r16p self_not_eq_R16P proc~norml2 normL2 proc~self_not_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R16P Source Code elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R16P","tags":"","loc":"proc/self_not_eq_r16p.html","title":"self_not_eq_R16P – VecFor"},{"text":"private elemental function self_not_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_r4p~~CallsGraph proc~self_not_eq_r4p self_not_eq_R4P proc~norml2 normL2 proc~self_not_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R4P Source Code elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R4P","tags":"","loc":"proc/self_not_eq_r4p.html","title":"self_not_eq_R4P – VecFor"},{"text":"private elemental function self_not_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. Calls proc~~self_not_eq_r8p~~CallsGraph proc~self_not_eq_r8p self_not_eq_R8P proc~norml2 normL2 proc~self_not_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R8P Source Code elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. logical :: compare !< Operator result. compare = ( real ( scal , R_P ) /= normL2 ( self )) endfunction self_not_eq_R8P","tags":"","loc":"proc/self_not_eq_r8p.html","title":"self_not_eq_R8P – VecFor"},{"text":"private elemental function self_not_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 First selftor. type( vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. Calls proc~~self_not_eq_self~~CallsGraph proc~self_not_eq_self self_not_eq_self proc~norml2 normL2 proc~self_not_eq_self->proc~norml2 proc~normalize normalize proc~self_not_eq_self->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_self Source Code elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. class ( vector ), intent ( in ) :: self1 !< First selftor. type ( vector ), intent ( in ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( vector ) :: n1 !< Normalizations of self1. type ( vector ) :: n2 !< Normalizations of self2. compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif endfunction self_not_eq_self","tags":"","loc":"proc/self_not_eq_self.html","title":"self_not_eq_self – VecFor"},{"text":"private elemental function self_sub_ScalI1P(self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalI1P Source Code elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI1P","tags":"","loc":"proc/self_sub_scali1p.html","title":"self_sub_ScalI1P – VecFor"},{"text":"private elemental function self_sub_ScalI2P(self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalI2P Source Code elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI2P","tags":"","loc":"proc/self_sub_scali2p.html","title":"self_sub_ScalI2P – VecFor"},{"text":"private elemental function self_sub_ScalI4P(self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalI4P Source Code elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI4P","tags":"","loc":"proc/self_sub_scali4p.html","title":"self_sub_ScalI4P – VecFor"},{"text":"private elemental function self_sub_ScalI8P(self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalI8P Source Code elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !< Subtract self and scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalI8P","tags":"","loc":"proc/self_sub_scali8p.html","title":"self_sub_ScalI8P – VecFor"},{"text":"private elemental function self_sub_ScalR16P(self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalR16P Source Code elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR16P","tags":"","loc":"proc/self_sub_scalr16p.html","title":"self_sub_ScalR16P – VecFor"},{"text":"private elemental function self_sub_ScalR4P(self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalR4P Source Code elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR4P","tags":"","loc":"proc/self_sub_scalr4p.html","title":"self_sub_ScalR4P – VecFor"},{"text":"private elemental function self_sub_ScalR8P(self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_ScalR8P Source Code elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !< Subtract self and scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self % x - real ( scal , R_P ) sub % y = self % y - real ( scal , R_P ) sub % z = self % z - real ( scal , R_P ) endfunction self_sub_ScalR8P","tags":"","loc":"proc/self_sub_scalr8p.html","title":"self_sub_ScalR8P – VecFor"},{"text":"private elemental function self_sub_self(self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. Source Code self_sub_self Source Code elemental function self_sub_self ( self1 , self2 ) result ( sub ) !< Subtract self and self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: sub !< Operator result. sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z endfunction self_sub_self","tags":"","loc":"proc/self_sub_self.html","title":"self_sub_self – VecFor"},{"text":"private elemental function self_sum_ScalI1P(self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalI1P Source Code elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I1P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI1P","tags":"","loc":"proc/self_sum_scali1p.html","title":"self_sum_ScalI1P – VecFor"},{"text":"private elemental function self_sum_ScalI2P(self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalI2P Source Code elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I2P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI2P","tags":"","loc":"proc/self_sum_scali2p.html","title":"self_sum_ScalI2P – VecFor"},{"text":"private elemental function self_sum_ScalI4P(self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalI4P Source Code elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I4P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI4P","tags":"","loc":"proc/self_sum_scali4p.html","title":"self_sum_ScalI4P – VecFor"},{"text":"private elemental function self_sum_ScalI8P(self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalI8P Source Code elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !< Sum self and scalar (integer I8P). class ( vector ), intent ( in ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalI8P","tags":"","loc":"proc/self_sum_scali8p.html","title":"self_sum_ScalI8P – VecFor"},{"text":"private elemental function self_sum_ScalR16P(self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalR16P Source Code elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !< Sum self and scalar (real R16P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR16P","tags":"","loc":"proc/self_sum_scalr16p.html","title":"self_sum_ScalR16P – VecFor"},{"text":"private elemental function self_sum_ScalR4P(self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalR4P Source Code elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !< Sum self and scalar (real R4P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR4P","tags":"","loc":"proc/self_sum_scalr4p.html","title":"self_sum_ScalR4P – VecFor"},{"text":"private elemental function self_sum_ScalR8P(self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_ScalR8P Source Code elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !< Sum self and scalar (real R8P). class ( vector ), intent ( in ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = real ( scal , R_P ) + self % x summ % y = real ( scal , R_P ) + self % y summ % z = real ( scal , R_P ) + self % z endfunction self_sum_ScalR8P","tags":"","loc":"proc/self_sum_scalr8p.html","title":"self_sum_ScalR8P – VecFor"},{"text":"private elemental function self_sum_self(self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. Source Code self_sum_self Source Code elemental function self_sum_self ( self1 , self2 ) result ( summ ) !< Sum self and self. class ( vector ), intent ( in ) :: self1 !< Left hand side. type ( vector ), intent ( in ) :: self2 !< Right hand side. type ( vector ) :: summ !< Operator result. summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z endfunction self_sum_self","tags":"","loc":"proc/self_sum_self.html","title":"self_sum_self – VecFor"},{"text":"public elemental function sq_norm(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Square of the Norm. Called By proc~~sq_norm~~CalledByGraph proc~sq_norm sq_norm program~simple simple program~simple->proc~sq_norm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sq_norm Source Code elemental function sq_norm ( vec ) result ( sq ) !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . type ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: sq !< Square of the Norm. sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) endfunction sq_norm","tags":"","loc":"proc/sq_norm.html","title":"sq_norm – VecFor"},{"text":"private elemental function sq_norm_self(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Square of the Norm. Source Code sq_norm_self Source Code elemental function sq_norm_self ( vec ) result ( sq ) !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . class ( vector ), intent ( in ) :: vec !< Vector. real ( R_P ) :: sq !< Square of the Norm. sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) endfunction sq_norm_self","tags":"","loc":"proc/sq_norm_self.html","title":"sq_norm_self – VecFor"},{"text":"private elemental subroutine assign_ScalI1P(self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Source Code assign_ScalI1P Source Code elemental subroutine assign_ScalI1P ( self , scal ) !< Assignment between a scalar (integer I1P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I1P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI1P","tags":"","loc":"proc/assign_scali1p.html","title":"assign_ScalI1P – VecFor"},{"text":"private elemental subroutine assign_ScalI2P(self, scal) Assignment between a scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Source Code assign_ScalI2P Source Code elemental subroutine assign_ScalI2P ( self , scal ) !< Assignment between a scalar (integer I2P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I2P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI2P","tags":"","loc":"proc/assign_scali2p.html","title":"assign_ScalI2P – VecFor"},{"text":"private elemental subroutine assign_ScalI4P(self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Source Code assign_ScalI4P Source Code elemental subroutine assign_ScalI4P ( self , scal ) !< Assignment between a scalar (integer I4P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I4P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI4P","tags":"","loc":"proc/assign_scali4p.html","title":"assign_ScalI4P – VecFor"},{"text":"private elemental subroutine assign_ScalI8P(self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Source Code assign_ScalI8P Source Code elemental subroutine assign_ScalI8P ( self , scal ) !< Assignment between a scalar (integer I8P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. integer ( I8P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalI8P","tags":"","loc":"proc/assign_scali8p.html","title":"assign_ScalI8P – VecFor"},{"text":"private elemental subroutine assign_ScalR16P(self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Source Code assign_ScalR16P Source Code elemental subroutine assign_ScalR16P ( self , scal ) !< Assignment between a scalar (real R16P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R16P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR16P","tags":"","loc":"proc/assign_scalr16p.html","title":"assign_ScalR16P – VecFor"},{"text":"private elemental subroutine assign_ScalR4P(self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Source Code assign_ScalR4P Source Code elemental subroutine assign_ScalR4P ( self , scal ) !< Assignment between a scalar (real R4P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R4P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR4P","tags":"","loc":"proc/assign_scalr4p.html","title":"assign_ScalR4P – VecFor"},{"text":"private elemental subroutine assign_ScalR8P(self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Source Code assign_ScalR8P Source Code elemental subroutine assign_ScalR8P ( self , scal ) !< Assignment between a scalar (real R8P) and self. class ( vector ), intent ( inout ) :: self !< Left hand side. real ( R8P ), intent ( in ) :: scal !< Right hand side. self % x = real ( scal , R_P ) self % y = real ( scal , R_P ) self % z = real ( scal , R_P ) endsubroutine assign_ScalR8P","tags":"","loc":"proc/assign_scalr8p.html","title":"assign_ScalR8P – VecFor"},{"text":"private pure subroutine assign_self(self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self1 Left hand side. class( vector ), intent(in) :: self2 Right hand side. Source Code assign_self Source Code pure subroutine assign_self ( self1 , self2 ) !< Assignment between two selfs. class ( vector ), intent ( inout ) :: self1 !< Left hand side. class ( vector ), intent ( in ) :: self2 !< Right hand side. self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z endsubroutine assign_self","tags":"","loc":"proc/assign_self.html","title":"assign_self – VecFor"},{"text":"private elemental subroutine face_normal3_self(fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal3_self~~CallsGraph proc~face_normal3_self face_normal3_self proc~normalize normalize proc~face_normal3_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3_self Source Code elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). class ( vector ), intent ( inout ) :: fnormal !< Face normal. type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: s12 !< Face 1-2 diagonals. type ( vector ) :: s13 !< Face 1-3 diagonals. s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R_P * ( s12 . cross . s13 ) endif endsubroutine face_normal3_self","tags":"","loc":"proc/face_normal3_self.html","title":"face_normal3_self – VecFor"},{"text":"private elemental subroutine face_normal4_self(fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. type( vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal4_self~~CallsGraph proc~face_normal4_self face_normal4_self proc~normalize normalize proc~face_normal4_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4_self Source Code elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). class ( vector ), intent ( inout ) :: fnormal !< Face normal. type ( vector ), intent ( in ) :: pt1 !< First face point. type ( vector ), intent ( in ) :: pt2 !< Second face point. type ( vector ), intent ( in ) :: pt3 !< Third face point. type ( vector ), intent ( in ) :: pt4 !< Fourth face point. character ( 1 ), intent ( in ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( vector ) :: d13 !< Face 1-3 diagonals. type ( vector ) :: d24 !< Face 2-4 diagonals. d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R_P * ( d13 . cross . d24 ) endif endsubroutine face_normal4_self","tags":"","loc":"proc/face_normal4_self.html","title":"face_normal4_self – VecFor"},{"text":"private elemental subroutine init_vector_self(vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. Source Code init_vector_self Source Code elemental subroutine init_vector_self ( vec ) !< Initialize components of Vector variable. class ( vector ), intent ( inout ) :: vec !< Vector. vec % x = 0._R_P vec % y = 0._R_P vec % z = 0._R_P endsubroutine init_vector_self","tags":"","loc":"proc/init_vector_self.html","title":"init_vector_self – VecFor"},{"text":"private subroutine load_vector_self(vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code load_vector_self Source Code subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !< Load Vector data. class ( vector ), intent ( inout ) :: vec !< Vector data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. integer ( I8P ), intent ( in ), optional :: pos !< Position specifier. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine load_vector_self","tags":"","loc":"proc/load_vector_self.html","title":"load_vector_self – VecFor"},{"text":"private elemental subroutine normalize_self(vec) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the\n normalization value is set to normL2(vec)+smallR_P. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector to be normalized. Calls proc~~normalize_self~~CallsGraph proc~normalize_self normalize_self proc~norml2 normL2 proc~normalize_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize_self Source Code elemental subroutine normalize_self ( vec ) !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR_P the !< normalization value is set to normL2(vec)+smallR_P. class ( vector ), intent ( inout ) :: vec !< Vector to be normalized. real ( R_P ) :: nm !< Norm L2 of vector. nm = normL2 ( vec ) if ( nm < smallR_P ) then nm = nm + smallR_P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm endsubroutine normalize_self","tags":"","loc":"proc/normalize_self.html","title":"normalize_self – VecFor"},{"text":"private subroutine print_vector_self(vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Calls proc~~print_vector_self~~CallsGraph proc~print_vector_self print_vector_self interface~str str proc~print_vector_self->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_vector_self Source Code subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !< Print in a pretty ascii format the components of type Vector. class ( vector ), intent ( in ) :: vec !< Vector. integer ( I4P ), intent ( in ), optional :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string for outputs. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine print_vector_self","tags":"","loc":"proc/print_vector_self.html","title":"print_vector_self – VecFor"},{"text":"private subroutine save_vector_self(vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code save_vector_self Source Code subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !< Save Vector data. class ( vector ), intent ( in ) :: vec !< Vector data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. integer ( I8P ), intent ( in ), optional :: pos !< Position specifier. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) endsubroutine save_vector_self","tags":"","loc":"proc/save_vector_self.html","title":"save_vector_self – VecFor"},{"text":"private elemental subroutine set_vector_self(vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. real(kind=R_P), intent(in), optional :: x Cartesian component in x direction. real(kind=R_P), intent(in), optional :: y Cartesian component in y direction. real(kind=R_P), intent(in), optional :: z Cartesian component in z direction. Source Code set_vector_self Source Code elemental subroutine set_vector_self ( vec , x , y , z ) !< Set components of Vector variable. class ( vector ), intent ( inout ) :: vec !< Vector. real ( R_P ), intent ( in ), optional :: x !< Cartesian component in x direction. real ( R_P ), intent ( in ), optional :: y !< Cartesian component in y direction. real ( R_P ), intent ( in ), optional :: z !< Cartesian component in z direction. if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z endsubroutine set_vector_self","tags":"","loc":"proc/set_vector_self.html","title":"set_vector_self – VecFor"},{"text":"private elemental function digit_I1(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I1 Source Code elemental function digit_I1 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – VecFor"},{"text":"private elemental function digit_I2(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I2 Source Code elemental function digit_I2 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – VecFor"},{"text":"private elemental function digit_I4(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I4 Source Code elemental function digit_I4 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – VecFor"},{"text":"private elemental function digit_I8(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I8 Source Code elemental function digit_I8 ( n ) result ( digit ) !< Compute the number of digits in decimal base of the input integer. integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – VecFor"},{"text":"public subroutine check_endian() Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Arguments None Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_endian Source Code subroutine check_endian () !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. if ( is_little_endian ()) then endian = endianL else endian = endianB endif contains pure function is_little_endian () result ( is_little ) !< Check if the type of the bit ordering of the running architecture is little endian. logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – VecFor"},{"text":"public subroutine penf_init() Initialize PENF's variables that are not initialized into the definition specification. Arguments None Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_init Source Code subroutine penf_init () !< Initialize PENF's variables that are not initialized into the definition specification. call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P ! #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P ! #else ! BIR16P = int(BIR8P, kind=I2P) ; BYR16P = BIR16P/8_I2P ! #endif is_initialized = . true . endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – VecFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code penf_print Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !< Print to the specified unit the PENF's environment data. integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = R_P ) // ',' // FR_P // ',' // str ( n = DR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = MinR_P ) // ',' // str ( n = MaxR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R_P:  ' // str ( n = BIR_P ) // '/' // str ( n = BYR_P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   Zero:    ' // str ( Zero ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – VecFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size.html","title":"bit_size – VecFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits.","tags":"","loc":"interface/digit.html","title":"digit – VecFor"},{"text":"private elemental function bit_size_R16P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Source Code bit_size_R16P Source Code elemental function bit_size_R16P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – VecFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R4P Source Code elemental function bit_size_R4P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – VecFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R8P Source Code elemental function bit_size_R8P ( i ) result ( bits ) !< Compute the number of bits of a real variable. real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – VecFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_chr Source Code elemental function bit_size_chr ( i ) result ( bits ) !< Compute the number of bits of a character variable. character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – VecFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I1P Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – VecFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I2P Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – VecFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I4P Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – VecFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I8P Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !< Compute the number of bytes of an integer variable. integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – VecFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Source Code byte_size_R16P Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – VecFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R4P Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – VecFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R8P Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !< Compute the number of bytes of a real variable. real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. bytes = bit_size ( i ) / 8_I1P endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – VecFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_chr Source Code elemental function byte_size_chr ( i ) result ( bytes ) !< Compute the number of bytes of a character variable. character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. bytes = bit_size ( i ) / 8_I4P endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – VecFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~2~~CallsGraph interface~bit_size~2 bit_size proc~bit_size_chr bit_size_chr interface~bit_size~2->proc~bit_size_chr proc~bit_size_r8p bit_size_R8P interface~bit_size~2->proc~bit_size_r8p proc~bit_size_r4p bit_size_R4P interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – VecFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"interface/byte_size.html","title":"byte_size – VecFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I1P Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – VecFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I2P Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – VecFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I4P Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – VecFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I8P Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !< Convert bit-string to integer. character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – VecFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R16P Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – VecFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R4P Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – VecFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R8P Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !< Convert bit-string to real. character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – VecFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I1P Source Code elemental function bstr_I1P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B8.8)' ) n endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – VecFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I2P Source Code elemental function bstr_I2P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B16.16)' ) n endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – VecFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I4P Source Code elemental function bstr_I4P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B32.32)' ) n endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – VecFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I8P Source Code elemental function bstr_I8P ( n ) result ( bstr ) !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B64.64)' ) n endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – VecFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Source Code bstr_R16P Source Code elemental function bstr_R16P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B128.128)' ) n endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – VecFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R4P Source Code elemental function bstr_R4P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B32.32)' ) n endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – VecFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R8P Source Code elemental function bstr_R8P ( n ) result ( bstr ) !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. write ( bstr , '(B64.64)' ) n endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – VecFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – VecFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – VecFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – VecFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !< Convert string to integer. character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – VecFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Source Code ctor_R16P Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – VecFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R4P Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – VecFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R8P Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !< Convert string to real. character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – VecFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I1P Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – VecFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I2P Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – VecFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I4P Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !< Converting integer to string. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – VecFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I8P Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !< Convert integer to string. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – VecFor"},{"text":"private elemental function str_R16P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. Calls proc~~str_r16p~~CallsGraph proc~str_r16p str_R16P proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R16P Source Code elemental function str_R16P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – VecFor"},{"text":"private elemental function str_R4P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. Calls proc~~str_r4p~~CallsGraph proc~str_r4p str_R4P proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R4P Source Code elemental function str_R4P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – VecFor"},{"text":"private elemental function str_R8P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. Calls proc~~str_r8p~~CallsGraph proc~str_r8p str_R8P proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R8P Source Code elemental function str_R8P ( n , no_sign , compact ) result ( str ) !< Convert real to string. real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – VecFor"},{"text":"private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I1P Source Code pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – VecFor"},{"text":"private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I2P Source Code pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – VecFor"},{"text":"private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I4P Source Code pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – VecFor"},{"text":"private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I8P Source Code pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !< Convert integer array to string. integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – VecFor"},{"text":"private pure function str_a_R16P(n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R16P Source Code pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Converting real array to string. real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – VecFor"},{"text":"private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R4P Source Code pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – VecFor"},{"text":"private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R8P Source Code pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !< Convert real array to string. real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – VecFor"},{"text":"private elemental function str_bol(n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_bol Source Code elemental function str_bol ( n ) result ( str ) !< Convert logical to string. logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. write ( str , '(L1)' ) n endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – VecFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I1P Source Code elemental function strf_I1P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – VecFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I2P Source Code elemental function strf_I2P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – VecFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I4P Source Code elemental function strf_I4P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – VecFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I8P Source Code elemental function strf_I8P ( fm , n ) result ( str ) !< Convert integer to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – VecFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Source Code strf_R16P Source Code elemental function strf_R16P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – VecFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R4P Source Code elemental function strf_R4P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – VecFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R8P Source Code elemental function strf_R8P ( fm , n ) result ( str ) !< Convert real to string. character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. write ( str , trim ( fm )) n endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – VecFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I1P Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – VecFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I2P Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – VecFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I4P Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !< Convert integer to string, prefixing with the right number of zeros. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – VecFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I8P Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !< Converting integer to string, prefixing with the right number of zeros. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – VecFor"},{"text":"private pure subroutine compact_real_string(string) Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~str_r16p str_R16P proc~str_r16p->proc~compact_real_string proc~str_r8p str_R8P proc~str_r8p->proc~compact_real_string proc~str_r4p str_R4P proc~str_r4p->proc~compact_real_string proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_r4p interface~str->proc~str_a_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p proc~str_a_r4p->proc~str_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compact_real_string Source Code pure subroutine compact_real_string ( string ) !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif endsubroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string – VecFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p interface~str str proc~bctoi_i4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i8p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i2p->interface~str proc~bctor_r4p->interface~str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/bcton.html","title":"bcton – VecFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number.","tags":"","loc":"interface/bstr.html","title":"bstr – VecFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/cton.html","title":"cton – VecFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p proc~str_a_i4p->proc~str_i4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~print_vector_self print_vector_self proc~print_vector_self->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number.","tags":"","loc":"interface/str.html","title":"str – VecFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros.","tags":"","loc":"interface/strz.html","title":"strz – VecFor"},{"text":"Uses: iso_fortran_env penf module~~vecfor~~UsesGraph module~vecfor vecfor iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->module~vecfor module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. VecFor, Vector algebra class for Fortran poor people This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with\n parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of\n reference.\n All the vectorial math procedures (cross, dot products, parallel…) assume a three-dimensional cartesian frame of reference.\n The operators of assignment ( = ), multiplication ( * ), division ( / ), sum ( + ) and subtraction ( - ) have been overloaded.\n Furthermore the dot and cross products have been defined.\n Therefore this module provides a far-complete algebra based on Vector derived type. Used By module~~vecfor~~UsedByGraph module~vecfor vecfor program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ex ey ez Derived Types vector vector_ptr Functions I1P_eq_self I1P_great_eq_self I1P_great_self I1P_low_eq_self I1P_low_self I1P_not_eq_self I2P_eq_self I2P_great_eq_self I2P_great_self I2P_low_eq_self I2P_low_self I2P_not_eq_self I4P_eq_self I4P_great_eq_self I4P_great_self I4P_low_eq_self I4P_low_self I4P_not_eq_self I8P_eq_self I8P_great_eq_self I8P_great_self I8P_low_eq_self I8P_low_self I8P_not_eq_self R16P_eq_self R16P_great_eq_self R16P_great_self R16P_low_eq_self R16P_low_self R16P_not_eq_self R4P_eq_self R4P_great_eq_self R4P_great_self R4P_low_eq_self R4P_low_self R4P_not_eq_self R8P_eq_self R8P_great_eq_self R8P_great_self R8P_low_eq_self R8P_low_self R8P_not_eq_self ScalI1P_mul_self ScalI1P_sub_self ScalI1P_sum_self ScalI2P_mul_self ScalI2P_sub_self ScalI2P_sum_self ScalI4P_mul_self ScalI4P_sub_self ScalI4P_sum_self ScalI8P_mul_self ScalI8P_sub_self ScalI8P_sum_self ScalR16P_mul_self ScalR16P_sub_self ScalR16P_sum_self ScalR4P_mul_self ScalR4P_sub_self ScalR4P_sum_self ScalR8P_mul_self ScalR8P_sub_self ScalR8P_sum_self crossproduct dotproduct face_normal3 face_normal4 iolen_vector_self negative_self normL2 normL2_self normalize normalized_self orthogonal parallel positive_self self_div_ScalI1P self_div_ScalI2P self_div_ScalI4P self_div_ScalI8P self_div_ScalR16P self_div_ScalR4P self_div_ScalR8P self_div_self self_eq_I1P self_eq_I2P self_eq_I4P self_eq_I8P self_eq_R16P self_eq_R4P self_eq_R8P self_eq_self self_great_I1P self_great_I2P self_great_I4P self_great_I8P self_great_R16P self_great_R4P self_great_R8P self_great_eq_I1P self_great_eq_I2P self_great_eq_I4P self_great_eq_I8P self_great_eq_R16P self_great_eq_R4P self_great_eq_R8P self_great_eq_self self_great_self self_low_I1P self_low_I2P self_low_I4P self_low_I8P self_low_R16P self_low_R4P self_low_R8P self_low_eq_I1P self_low_eq_I2P self_low_eq_I4P self_low_eq_I8P self_low_eq_R16P self_low_eq_R4P self_low_eq_R8P self_low_eq_self self_low_self self_mul_ScalI1P self_mul_ScalI2P self_mul_ScalI4P self_mul_ScalI8P self_mul_ScalR16P self_mul_ScalR4P self_mul_ScalR8P self_mul_self self_not_eq_I1P self_not_eq_I2P self_not_eq_I4P self_not_eq_I8P self_not_eq_R16P self_not_eq_R4P self_not_eq_R8P self_not_eq_self self_sub_ScalI1P self_sub_ScalI2P self_sub_ScalI4P self_sub_ScalI8P self_sub_ScalR16P self_sub_ScalR4P self_sub_ScalR8P self_sub_self self_sum_ScalI1P self_sum_ScalI2P self_sum_ScalI4P self_sum_ScalI8P self_sum_ScalR16P self_sum_ScalR4P self_sum_ScalR8P self_sum_self sq_norm sq_norm_self Subroutines assign_ScalI1P assign_ScalI2P assign_ScalI4P assign_ScalI8P assign_ScalR16P assign_ScalR4P assign_ScalR8P assign_self face_normal3_self face_normal4_self init_vector_self load_vector_self normalize_self print_vector_self save_vector_self set_vector_self Variables Type Visibility Attributes Name Initial type( vector ), public, parameter :: ex = Vector(1._R_P, 0._R_P, 0._R_P) X direction versor. type( vector ), public, parameter :: ey = Vector(0._R_P, 1._R_P, 0._R_P) Y direction versor. type( vector ), public, parameter :: ez = Vector(0._R_P, 0._R_P, 1._R_P) Z direction versor. Derived Types type, public :: vector Vector class. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: x = 0._R_P Cartesian component in x direction. real(kind=R_P), public :: y = 0._R_P Cartesian component in y direction. real(kind=R_P), public :: z = 0._R_P Cartesian component in z direction. Type-Bound Procedures procedure, private, pass(self ) :: I1P_eq_self procedure, private, pass(self ) :: I1P_great_eq_self procedure, private, pass(self ) :: I1P_great_self procedure, private, pass(self ) :: I1P_low_eq_self procedure, private, pass(self ) :: I1P_low_self procedure, private, pass(self ) :: I1P_not_eq_self procedure, private, pass(self ) :: I2P_eq_self procedure, private, pass(self ) :: I2P_great_eq_self procedure, private, pass(self ) :: I2P_great_self procedure, private, pass(self ) :: I2P_low_eq_self procedure, private, pass(self ) :: I2P_low_self procedure, private, pass(self ) :: I2P_not_eq_self procedure, private, pass(self ) :: I4P_eq_self procedure, private, pass(self ) :: I4P_great_eq_self procedure, private, pass(self ) :: I4P_great_self procedure, private, pass(self ) :: I4P_low_eq_self procedure, private, pass(self ) :: I4P_low_self procedure, private, pass(self ) :: I4P_not_eq_self procedure, private, pass(self ) :: I8P_eq_self procedure, private, pass(self ) :: I8P_great_eq_self procedure, private, pass(self ) :: I8P_great_self procedure, private, pass(self ) :: I8P_low_eq_self procedure, private, pass(self ) :: I8P_low_self procedure, private, pass(self ) :: I8P_not_eq_self procedure, private, pass(self ) :: R4P_eq_self procedure, private, pass(self ) :: R4P_great_eq_self procedure, private, pass(self ) :: R4P_great_self procedure, private, pass(self ) :: R4P_low_eq_self procedure, private, pass(self ) :: R4P_low_self procedure, private, pass(self ) :: R4P_not_eq_self procedure, private, pass(self ) :: R8P_eq_self procedure, private, pass(self ) :: R8P_great_eq_self procedure, private, pass(self ) :: R8P_great_self procedure, private, pass(self ) :: R8P_low_eq_self procedure, private, pass(self ) :: R8P_low_self procedure, private, pass(self ) :: R8P_not_eq_self procedure, private, pass(self ) :: ScalI1P_mul_self procedure, private, pass(self ) :: ScalI1P_sub_self procedure, private, pass(self ) :: ScalI1P_sum_self procedure, private, pass(self ) :: ScalI2P_mul_self procedure, private, pass(self ) :: ScalI2P_sub_self procedure, private, pass(self ) :: ScalI2P_sum_self procedure, private, pass(self ) :: ScalI4P_mul_self procedure, private, pass(self ) :: ScalI4P_sub_self procedure, private, pass(self ) :: ScalI4P_sum_self procedure, private, pass(self ) :: ScalI8P_mul_self procedure, private, pass(self ) :: ScalI8P_sub_self procedure, private, pass(self ) :: ScalI8P_sum_self procedure, private, pass(self ) :: ScalR4P_mul_self procedure, private, pass(self ) :: ScalR4P_sub_self procedure, private, pass(self ) :: ScalR4P_sum_self procedure, private, pass(self ) :: ScalR8P_mul_self procedure, private, pass(self ) :: ScalR8P_sub_self procedure, private, pass(self ) :: ScalR8P_sum_self procedure, private, pass(self ) :: assign_ScalI1P procedure, private, pass(self ) :: assign_ScalI2P procedure, private, pass(self ) :: assign_ScalI4P procedure, private, pass(self ) :: assign_ScalI8P procedure, private, pass(self ) :: assign_ScalR4P procedure, private, pass(self ) :: assign_ScalR8P procedure, private, pass(self1) :: assign_self generic, public :: assignment(=) => assign_self, assign_ScalR8P, assign_ScalR4P, assign_ScalI8P, assign_ScalI4P, assign_ScalI2P, assign_ScalI1P procedure, private, pass(vec1) :: crossproduct procedure, private, pass(vec1) :: dotproduct procedure, public :: face_normal3 => face_normal3_self procedure, public :: face_normal4 => face_normal4_self procedure, public :: init => init_vector_self procedure, public :: iolen => iolen_vector_self procedure, public :: load => load_vector_self procedure, private, pass(self ) :: negative_self procedure, public :: normL2 => normL2_self procedure, public :: normalize => normalize_self procedure, public :: normalized => normalized_self generic, public :: operator(*) => self_mul_self, ScalR8P_mul_self, self_mul_ScalR8P, ScalR4P_mul_self, self_mul_ScalR4P, ScalI8P_mul_self, self_mul_ScalI8P, ScalI4P_mul_self, self_mul_ScalI4P, ScalI2P_mul_self, self_mul_ScalI2P, ScalI1P_mul_self, self_mul_ScalI1P generic, public :: operator(+) => positive_self, self_sum_self, ScalR8P_sum_self, self_sum_ScalR8P, ScalR4P_sum_self, self_sum_ScalR4P, ScalI8P_sum_self, self_sum_ScalI8P, ScalI4P_sum_self, self_sum_ScalI4P, ScalI2P_sum_self, self_sum_ScalI2P, ScalI1P_sum_self, self_sum_ScalI1P generic, public :: operator(-) => negative_self, self_sub_self, ScalR8P_sub_self, self_sub_ScalR8P, ScalR4P_sub_self, self_sub_ScalR4P, ScalI8P_sub_self, self_sub_ScalI8P, ScalI4P_sub_self, self_sub_ScalI4P, ScalI2P_sub_self, self_sub_ScalI2P, ScalI1P_sub_self, self_sub_ScalI1P generic, public :: operator(.cross.) => crossproduct generic, public :: operator(.dot.) => dotproduct generic, public :: operator(.ortho.) => orthogonal generic, public :: operator(.paral.) => parallel generic, public :: operator(/) => self_div_self, self_div_ScalR8P, self_div_ScalR4P, self_div_ScalI8P, self_div_ScalI4P, self_div_ScalI2P, self_div_ScalI1P generic, public :: operator(/=) => self_not_eq_self, R8P_not_eq_self, self_not_eq_R8P, R4P_not_eq_self, self_not_eq_R4P, I8P_not_eq_self, self_not_eq_I8P, I4P_not_eq_self, self_not_eq_I4P, I2P_not_eq_self, self_not_eq_I2P, I1P_not_eq_self, self_not_eq_I1P generic, public :: operator(<) => self_low_self, R8P_low_self, self_low_R8P, R4P_low_self, self_low_R4P, I8P_low_self, self_low_I8P, I4P_low_self, self_low_I4P, I2P_low_self, self_low_I2P, I1P_low_self, self_low_I1P generic, public :: operator(<=) => self_low_eq_self, R8P_low_eq_self, self_low_eq_R8P, R4P_low_eq_self, self_low_eq_R4P, I8P_low_eq_self, self_low_eq_I8P, I4P_low_eq_self, self_low_eq_I4P, I2P_low_eq_self, self_low_eq_I2P, I1P_low_eq_self, self_low_eq_I1P generic, public :: operator(==) => self_eq_self, R8P_eq_self, self_eq_R8P, R4P_eq_self, self_eq_R4P, I8P_eq_self, self_eq_I8P, I4P_eq_self, self_eq_I4P, I2P_eq_self, self_eq_I2P, I1P_eq_self, self_eq_I1P generic, public :: operator(>) => self_great_self, R8P_great_self, self_great_R8P, R4P_great_self, self_great_R4P, I8P_great_self, self_great_I8P, I4P_great_self, self_great_I4P, I2P_great_self, self_great_I2P, I1P_great_self, self_great_I1P generic, public :: operator(>=) => self_great_eq_self, R8P_great_eq_self, self_great_eq_R8P, R4P_great_eq_self, self_great_eq_R4P, I8P_great_eq_self, self_great_eq_I8P, I4P_great_eq_self, self_great_eq_I4P, I2P_great_eq_self, self_great_eq_I2P, I1P_great_eq_self, self_great_eq_I1P procedure, private, pass(vec1) :: orthogonal procedure, private, pass(vec1) :: parallel procedure, private, pass(self ) :: positive_self procedure, public :: print => print_vector_self procedure, public :: save => save_vector_self procedure, private, pass(self ) :: self_div_ScalI1P procedure, private, pass(self ) :: self_div_ScalI2P procedure, private, pass(self ) :: self_div_ScalI4P procedure, private, pass(self ) :: self_div_ScalI8P procedure, private, pass(self ) :: self_div_ScalR4P procedure, private, pass(self ) :: self_div_ScalR8P procedure, private, pass(self1) :: self_div_self procedure, private, pass(self ) :: self_eq_I1P procedure, private, pass(self ) :: self_eq_I2P procedure, private, pass(self ) :: self_eq_I4P procedure, private, pass(self ) :: self_eq_I8P procedure, private, pass(self ) :: self_eq_R4P procedure, private, pass(self ) :: self_eq_R8P procedure, private, pass(self1) :: self_eq_self procedure, private, pass(self ) :: self_great_I1P procedure, private, pass(self ) :: self_great_I2P procedure, private, pass(self ) :: self_great_I4P procedure, private, pass(self ) :: self_great_I8P procedure, private, pass(self ) :: self_great_R4P procedure, private, pass(self ) :: self_great_R8P procedure, private, pass(self ) :: self_great_eq_I1P procedure, private, pass(self ) :: self_great_eq_I2P procedure, private, pass(self ) :: self_great_eq_I4P procedure, private, pass(self ) :: self_great_eq_I8P procedure, private, pass(self ) :: self_great_eq_R4P procedure, private, pass(self ) :: self_great_eq_R8P procedure, private, pass(self1) :: self_great_eq_self procedure, private, pass(self1) :: self_great_self procedure, private, pass(self ) :: self_low_I1P procedure, private, pass(self ) :: self_low_I2P procedure, private, pass(self ) :: self_low_I4P procedure, private, pass(self ) :: self_low_I8P procedure, private, pass(self ) :: self_low_R4P procedure, private, pass(self ) :: self_low_R8P procedure, private, pass(self ) :: self_low_eq_I1P procedure, private, pass(self ) :: self_low_eq_I2P procedure, private, pass(self ) :: self_low_eq_I4P procedure, private, pass(self ) :: self_low_eq_I8P procedure, private, pass(self ) :: self_low_eq_R4P procedure, private, pass(self ) :: self_low_eq_R8P procedure, private, pass(self1) :: self_low_eq_self procedure, private, pass(self1) :: self_low_self procedure, private, pass(self ) :: self_mul_ScalI1P procedure, private, pass(self ) :: self_mul_ScalI2P procedure, private, pass(self ) :: self_mul_ScalI4P procedure, private, pass(self ) :: self_mul_ScalI8P procedure, private, pass(self ) :: self_mul_ScalR4P procedure, private, pass(self ) :: self_mul_ScalR8P procedure, private, pass(self1) :: self_mul_self procedure, private, pass(self ) :: self_not_eq_I1P procedure, private, pass(self ) :: self_not_eq_I2P procedure, private, pass(self ) :: self_not_eq_I4P procedure, private, pass(self ) :: self_not_eq_I8P procedure, private, pass(self ) :: self_not_eq_R4P procedure, private, pass(self ) :: self_not_eq_R8P procedure, private, pass(self1) :: self_not_eq_self procedure, private, pass(self ) :: self_sub_ScalI1P procedure, private, pass(self ) :: self_sub_ScalI2P procedure, private, pass(self ) :: self_sub_ScalI4P procedure, private, pass(self ) :: self_sub_ScalI8P procedure, private, pass(self ) :: self_sub_ScalR4P procedure, private, pass(self ) :: self_sub_ScalR8P procedure, private, pass(self1) :: self_sub_self procedure, private, pass(self ) :: self_sum_ScalI1P procedure, private, pass(self ) :: self_sum_ScalI2P procedure, private, pass(self ) :: self_sum_ScalI4P procedure, private, pass(self ) :: self_sum_ScalI8P procedure, private, pass(self ) :: self_sum_ScalR4P procedure, private, pass(self ) :: self_sum_ScalR8P procedure, private, pass(self1) :: self_sum_self procedure, public :: set => set_vector_self procedure, public :: sq_norm => sq_norm_self type, public :: vector_ptr Pointer of Vector for creating array of pointers of Vector. Components Type Visibility Attributes Name Initial type( vector ), public, pointer :: p => null() Functions private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R16P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value logical Operator result. private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR16P_mul_self (scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR16P_sub_self (scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR16P_sum_self (scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal Left hand side. class( vector ), intent(in) :: self Right hand side. Return Value type( vector ) Operator result. private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Cross product vector. private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R_P) Dot product. public elemental function face_normal3 (pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( vector ) Face normal. public elemental function face_normal4 (pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. type( vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( vector ) Face normal. private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. public elemental function normL2 (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Norm L2. private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Norm L2. public elemental function normalize (vec) result(norm) Normalize a vector. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector to be normalized. Return Value type( vector ) Vector normalized. private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector to be normalized. Return Value type( vector ) Normalized copy. private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 orthogonal to vec2. private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( vector ), intent(in) :: vec2 Second vector. Return Value type( vector ) Component of of vec1 parallel to vec2. private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Unary object. Return Value type( vector ) Operator result. private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalR16P (self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise.\n Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value logical Operator result. private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalR16P (self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value logical Operator result. private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 First selftor. type( vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalR16P (self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalR16P (self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. Return Value type( vector ) Operator result. private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: self1 Left hand side. type( vector ), intent(in) :: self2 Right hand side. Return Value type( vector ) Operator result. public elemental function sq_norm (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Square of the Norm. private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. Return Value real(kind=R_P) Square of the Norm. Subroutines private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I1P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI2P (self, scal) Assignment between a scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I2P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I4P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. integer(kind=I8P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalR16P (self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R16P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R4P), intent(in) :: scal Right hand side. private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self Left hand side. real(kind=R8P), intent(in) :: scal Right hand side. private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: self1 Left hand side. class( vector ), intent(in) :: self2 Right hand side. private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: fnormal Face normal. type( vector ), intent(in) :: pt1 First face point. type( vector ), intent(in) :: pt2 Second face point. type( vector ), intent(in) :: pt3 Third face point. type( vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector to be normalized. private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: vec Vector. real(kind=R_P), intent(in), optional :: x Cartesian component in x direction. real(kind=R_P), intent(in), optional :: y Cartesian component in y direction. real(kind=R_P), intent(in), optional :: z Cartesian component in z direction.","tags":"","loc":"module/vecfor.html","title":"vecfor – VecFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Portability Environment for Fortran poor people. Used By module~~penf~~UsedByGraph module~penf penf module~vecfor vecfor module~penf->module~vecfor program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size digit Functions digit_I1 digit_I2 digit_I4 digit_I8 Subroutines check_endian penf_init penf_print Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Functions private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Subroutines public subroutine check_endian () Check the type of bit ordering (big or little endian) of the running architecture. Arguments None public subroutine penf_init () Initialize PENF's variables that are not initialized into the definition specification. Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message.","tags":"","loc":"module/penf.html","title":"penf – VecFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf penf module~penf_b_size->module~penf module~penf_stringify->module~penf module~vecfor vecfor module~penf->module~vecfor program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size byte_size Functions bit_size_R16P bit_size_R4P bit_size_R8P bit_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P byte_size_chr Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Functions private elemental function bit_size_R16P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R16P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – VecFor"},{"text":"PENF global parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf penf module~penf_global_parameters_variables->module~penf module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~vecfor vecfor module~penf->module~vecfor module~penf_stringify->module~penf program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables BII1P BII2P BII4P BII8P BII_P BIR16P BIR4P BIR8P BIR_P BYI1P BYI2P BYI4P BYI8P BYI_P BYR16P BYR4P BYR8P BYR_P DI1P DI2P DI4P DI8P DI_P DR16P DR4P DR8P DR_P FI1P FI1PZP FI2P FI2PZP FI4P FI4PZP FI8P FI8PZP FI_P FI_PZP FR16P FR4P FR8P FR_P I1P I2P I4P I8P INTEGER_FORMATS_LIST INTEGER_KINDS_LIST I_P MaxI1P MaxI2P MaxI4P MaxI8P MaxI_P MaxR16P MaxR4P MaxR8P MaxR_P MinI1P MinI2P MinI4P MinI8P MinI_P MinR16P MinR4P MinR8P MinR_P R16P R4P R8P REAL_FORMATS_LIST REAL_KINDS_LIST R_P Zero ZeroR16 ZeroR4 ZeroR8 endian endianB endianL is_initialized smallR16P smallR4P smallR8P smallR_P Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. integer, public, parameter :: I_P = I4P Default integer precision. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MaxI_P = huge(1_I_P) Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R_P), public, parameter :: MaxR_P = huge(1._R_P) Maximum value of kind=R_P real. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MinI_P = -huge(1_I_P) Minimum value of kind=I_P integer. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R_P), public, parameter :: MinR_P = -huge(1._R_P) Minimum value of kind=R_P real. integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. integer, public, parameter :: R_P = R8P Default real precision. real(kind=R_P), public, parameter :: Zero = nearest(1._R_P, 1._R_P)-nearest(1._R_P, -1._R_P) Smallest representable difference of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: endianB = 0 Big endian parameter. integer, public, parameter :: endianL = 1 Little endian parameter. logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R_P), public, parameter :: smallR_P = tiny(1._R_P) Smallest representable value of kind=R_P real.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – VecFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_b_size->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf module~vecfor vecfor module~penf->module~vecfor program~kinds kinds module~vecfor->program~kinds program~simple simple module~vecfor->program~simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bcton bstr cton str strz Functions bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bctor_R16P bctor_R4P bctor_R8P bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P ctor_R16P ctor_R4P ctor_R8P str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz_I1P strz_I2P strz_I4P strz_I8P Subroutines compact_real_string Interfaces public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Functions private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctor_R16P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R16P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctor_R16P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function str_R16P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R16P (n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function strf_R16P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Subroutines private pure subroutine compact_real_string (string) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – VecFor"},{"text":"Uses: vecfor program~~kinds~~UsesGraph program~kinds kinds module~vecfor vecfor module~vecfor->program~kinds iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->module~vecfor module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramkindsUsesGraph = svgPanZoom('#programkindsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Kinds regression test for VecFor library. Try to test the algebra of mixed vector/numbers for all supported kinds. Variables I1P I2P I4P I8P R16P R16P R4P R8P vector1 vector2 vector3 Source Code kinds Variables Type Attributes Name Initial integer, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, parameter :: R16P = selected_real_kind(33, 4931) 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. integer, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. type( vector ) :: vector1 Vector dummy variable. type( vector ) :: vector2 Vector dummy variable. type( vector ) :: vector3 Vector dummy variable. Source Code program kinds !< Kinds regression test for VecFor library. !< !< Try to test the algebra of mixed vector/numbers for all supported kinds. use vecfor implicit none #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. call vector1 % set ( x =- 1._R8P , y =- 1._R8P , z =- 1._R8P ) call vector1 % init () print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [1, 1, 1] testing assignments by scalar' vector2 = 1._R16P vector2 = 1._R8P vector2 = 1._R4P vector2 = 1_I8P vector2 = 1_I4P vector2 = 1_I2P vector2 = 1_I1P print \"(A)\" , ' Verify * operator, multiply by 1 defined in any supported number formats' vector1 = 1._R16P * vector1 vector1 = 1._R8P * vector1 vector1 = 1._R4P * vector1 vector1 = 1_I8P * vector1 vector1 = 1_I4P * vector1 vector1 = 1_I2P * vector1 vector1 = 1_I1P * vector1 vector1 = vector1 * 1._R16P vector1 = vector1 * 1._R8P vector1 = vector1 * 1._R4P vector1 = vector1 * 1_I8P vector1 = vector1 * 1_I4P vector1 = vector1 * 1_I2P vector1 = vector1 * 1_I1P call vector1 % print print \"(A)\" , ' Verify * operator between vectors, vector1 * vector2' vector1 = vector1 * vector2 call vector1 % print print \"(A)\" , ' Verify / operator, diveded by 1 defined in any supported number formats' vector1 = vector1 / 1._R16P vector1 = vector1 / 1._R8P vector1 = vector1 / 1._R4P vector1 = vector1 / 1_I8P vector1 = vector1 / 1_I4P vector1 = vector1 / 1_I2P vector1 = vector1 / 1_I1P call vector1 % print print \"(A)\" , ' Verify / operator between vectors, vector1 / vector2' vector1 = vector1 / vector2 call vector1 % print print \"(A)\" , ' Verify + operator, add 1 (14 times) defined in any supported number formats' vector1 = 1._R16P + vector1 vector1 = 1._R8P + vector1 vector1 = 1._R4P + vector1 vector1 = 1_I8P + vector1 vector1 = 1_I4P + vector1 vector1 = 1_I2P + vector1 vector1 = 1_I1P + vector1 vector1 = + vector1 vector1 = vector1 + 1._R16P vector1 = vector1 + 1._R8P vector1 = vector1 + 1._R4P vector1 = vector1 + 1_I8P vector1 = vector1 + 1_I4P vector1 = vector1 + 1_I2P vector1 = vector1 + 1_I1P call vector1 % print print \"(A)\" , ' Verify + operator between vectors, vector1 + vector2' vector1 = vector1 + vector2 call vector1 % print print \"(A)\" , ' Verify - operator, subtract 1 (14 times) defined in any supported number formats' vector1 = 1._R16P - vector1 vector1 =- 1._R8P - vector1 vector1 = 1._R4P - vector1 vector1 =- 1_I8P - vector1 vector1 = 1_I4P - vector1 vector1 =- 1_I2P - vector1 vector1 = 1_I1P - vector1 vector1 = - vector1 vector1 = vector1 - 1._R16P vector1 = vector1 - 1._R8P vector1 = vector1 - 1._R4P vector1 = vector1 - 1_I8P vector1 = vector1 - 1_I4P vector1 = vector1 - 1_I2P vector1 = vector1 - 1_I1P call vector1 % print print \"(A)\" , ' Verify - operator between vectors, vector1 - vector2' vector1 = vector1 - vector2 call vector1 % print print \"(A)\" , ' Verify save/load methods' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' ) call vector1 % save ( unit = 2 ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 ) close ( unit = 2 ) call vector3 % print vector3 = 0 print \"(A)\" , ' Verify save/load methods with stream-accessed file' open ( unit = 2 , form = 'UNFORMATTED' , status = 'SCRATCH' , access = 'STREAM' ) call vector1 % save ( unit = 2 , pos = 1_I8P ) rewind ( unit = 2 ) call vector3 % load ( unit = 2 , pos = 1_I8P ) close ( unit = 2 ) call vector3 % print print \"(A)\" , ' Verify < operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<1._R16P => ' , ( vector1 < 1._R16P ) print \"(A,L1)\" , 'vector1<1._R8P  => ' , ( vector1 < 1._R8P ) print \"(A,L1)\" , 'vector1<1._R4P  => ' , ( vector1 < 1._R4P ) print \"(A,L1)\" , 'vector1<1_I8P   => ' , ( vector1 < 1_I8P ) print \"(A,L1)\" , 'vector1<1_I4P   => ' , ( vector1 < 1_I4P ) print \"(A,L1)\" , 'vector1<1_I2P   => ' , ( vector1 < 1_I2P ) print \"(A,L1)\" , 'vector1<1_I1P   => ' , ( vector1 < 1_I1P ) print \"(A,L1)\" , '1._R16P<vector1 => ' , ( 1._R16P < vector1 ) print \"(A,L1)\" , '1._R8P <vector1 => ' , ( 1._R8P < vector1 ) print \"(A,L1)\" , '1._R4P <vector1 => ' , ( 1._R4P < vector1 ) print \"(A,L1)\" , '1_I8P  <vector1 => ' , ( 1_I8P < vector1 ) print \"(A,L1)\" , '1_I4P  <vector1 => ' , ( 1_I4P < vector1 ) print \"(A,L1)\" , '1_I2P  <vector1 => ' , ( 1_I2P < vector1 ) print \"(A,L1)\" , '1_I1P  <vector1 => ' , ( 1_I1P < vector1 ) print \"(A,L1)\" , 'vector1<vector2 => ' , ( vector1 < vector2 ) print \"(A)\" , ' Verify <= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1<=1._R16P => ' , ( vector1 <= 1._R16P ) print \"(A,L1)\" , 'vector1<=1._R8P  => ' , ( vector1 <= 1._R8P ) print \"(A,L1)\" , 'vector1<=1._R4P  => ' , ( vector1 <= 1._R4P ) print \"(A,L1)\" , 'vector1<=1_I8P   => ' , ( vector1 <= 1_I8P ) print \"(A,L1)\" , 'vector1<=1_I4P   => ' , ( vector1 <= 1_I4P ) print \"(A,L1)\" , 'vector1<=1_I2P   => ' , ( vector1 <= 1_I2P ) print \"(A,L1)\" , 'vector1<=1_I1P   => ' , ( vector1 <= 1_I1P ) print \"(A,L1)\" , '1._R16P<=vector1 => ' , ( 1._R16P <= vector1 ) print \"(A,L1)\" , '1._R8P <=vector1 => ' , ( 1._R8P <= vector1 ) print \"(A,L1)\" , '1._R4P <=vector1 => ' , ( 1._R4P <= vector1 ) print \"(A,L1)\" , '1_I8P  <=vector1 => ' , ( 1_I8P <= vector1 ) print \"(A,L1)\" , '1_I4P  <=vector1 => ' , ( 1_I4P <= vector1 ) print \"(A,L1)\" , '1_I2P  <=vector1 => ' , ( 1_I2P <= vector1 ) print \"(A,L1)\" , '1_I1P  <=vector1 => ' , ( 1_I1P <= vector1 ) print \"(A,L1)\" , 'vector1<=vector2 => ' , ( vector1 <= vector2 ) print \"(A)\" , ' Verify == operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1==1._R16P => ' , ( vector1 == 1._R16P ) print \"(A,L1)\" , 'vector1==1._R8P  => ' , ( vector1 == 1._R8P ) print \"(A,L1)\" , 'vector1==1._R4P  => ' , ( vector1 == 1._R4P ) print \"(A,L1)\" , 'vector1==1_I8P   => ' , ( vector1 == 1_I8P ) print \"(A,L1)\" , 'vector1==1_I4P   => ' , ( vector1 == 1_I4P ) print \"(A,L1)\" , 'vector1==1_I2P   => ' , ( vector1 == 1_I2P ) print \"(A,L1)\" , 'vector1==1_I1P   => ' , ( vector1 == 1_I1P ) print \"(A,L1)\" , '1._R16P==vector1 => ' , ( 1._R16P == vector1 ) print \"(A,L1)\" , '1._R8P ==vector1 => ' , ( 1._R8P == vector1 ) print \"(A,L1)\" , '1._R4P ==vector1 => ' , ( 1._R4P == vector1 ) print \"(A,L1)\" , '1_I8P  ==vector1 => ' , ( 1_I8P == vector1 ) print \"(A,L1)\" , '1_I4P  ==vector1 => ' , ( 1_I4P == vector1 ) print \"(A,L1)\" , '1_I2P  ==vector1 => ' , ( 1_I2P == vector1 ) print \"(A,L1)\" , '1_I1P  ==vector1 => ' , ( 1_I1P == vector1 ) print \"(A,L1)\" , 'vector1==vector2 => ' , ( vector1 == vector2 ) print \"(A,L1)\" , 'vector1==-vector1 => ' , ( vector1 ==- vector1 ) print \"(A)\" , ' Verify /= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1/=1._R16P => ' , ( vector1 /= 1._R16P ) print \"(A,L1)\" , 'vector1/=1._R8P  => ' , ( vector1 /= 1._R8P ) print \"(A,L1)\" , 'vector1/=1._R4P  => ' , ( vector1 /= 1._R4P ) print \"(A,L1)\" , 'vector1/=1_I8P   => ' , ( vector1 /= 1_I8P ) print \"(A,L1)\" , 'vector1/=1_I4P   => ' , ( vector1 /= 1_I4P ) print \"(A,L1)\" , 'vector1/=1_I2P   => ' , ( vector1 /= 1_I2P ) print \"(A,L1)\" , 'vector1/=1_I1P   => ' , ( vector1 /= 1_I1P ) print \"(A,L1)\" , '1._R16P/=vector1 => ' , ( 1._R16P /= vector1 ) print \"(A,L1)\" , '1._R8P /=vector1 => ' , ( 1._R8P /= vector1 ) print \"(A,L1)\" , '1._R4P /=vector1 => ' , ( 1._R4P /= vector1 ) print \"(A,L1)\" , '1_I8P  /=vector1 => ' , ( 1_I8P /= vector1 ) print \"(A,L1)\" , '1_I4P  /=vector1 => ' , ( 1_I4P /= vector1 ) print \"(A,L1)\" , '1_I2P  /=vector1 => ' , ( 1_I2P /= vector1 ) print \"(A,L1)\" , '1_I1P  /=vector1 => ' , ( 1_I1P /= vector1 ) print \"(A,L1)\" , 'vector1/=vector2 => ' , ( vector1 /= vector2 ) print \"(A,L1)\" , 'vector1/=-vector1 => ' , ( vector1 /=- vector1 ) print \"(A)\" , ' Verify >= operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>=1._R16P => ' , ( vector1 >= 1._R16P ) print \"(A,L1)\" , 'vector1>=1._R8P  => ' , ( vector1 >= 1._R8P ) print \"(A,L1)\" , 'vector1>=1._R4P  => ' , ( vector1 >= 1._R4P ) print \"(A,L1)\" , 'vector1>=1_I8P   => ' , ( vector1 >= 1_I8P ) print \"(A,L1)\" , 'vector1>=1_I4P   => ' , ( vector1 >= 1_I4P ) print \"(A,L1)\" , 'vector1>=1_I2P   => ' , ( vector1 >= 1_I2P ) print \"(A,L1)\" , 'vector1>=1_I1P   => ' , ( vector1 >= 1_I1P ) print \"(A,L1)\" , '1._R16P>=vector1 => ' , ( 1._R16P >= vector1 ) print \"(A,L1)\" , '1._R8P >=vector1 => ' , ( 1._R8P >= vector1 ) print \"(A,L1)\" , '1._R4P >=vector1 => ' , ( 1._R4P >= vector1 ) print \"(A,L1)\" , '1_I8P  >=vector1 => ' , ( 1_I8P >= vector1 ) print \"(A,L1)\" , '1_I4P  >=vector1 => ' , ( 1_I4P >= vector1 ) print \"(A,L1)\" , '1_I2P  >=vector1 => ' , ( 1_I2P >= vector1 ) print \"(A,L1)\" , '1_I1P  >=vector1 => ' , ( 1_I1P >= vector1 ) print \"(A,L1)\" , 'vector1>=vector2 => ' , ( vector1 >= vector2 ) print \"(A)\" , ' Verify > operator, compare with 1 (and vector2) defined in any supported number formats' print \"(A,L1)\" , 'vector1>1._R16P => ' , ( vector1 > 1._R16P ) print \"(A,L1)\" , 'vector1>1._R8P  => ' , ( vector1 > 1._R8P ) print \"(A,L1)\" , 'vector1>1._R4P  => ' , ( vector1 > 1._R4P ) print \"(A,L1)\" , 'vector1>1_I8P   => ' , ( vector1 > 1_I8P ) print \"(A,L1)\" , 'vector1>1_I4P   => ' , ( vector1 > 1_I4P ) print \"(A,L1)\" , 'vector1>1_I2P   => ' , ( vector1 > 1_I2P ) print \"(A,L1)\" , 'vector1>1_I1P   => ' , ( vector1 > 1_I1P ) print \"(A,L1)\" , '1._R16P>vector1 => ' , ( 1._R16P > vector1 ) print \"(A,L1)\" , '1._R8P >vector1 => ' , ( 1._R8P > vector1 ) print \"(A,L1)\" , '1._R4P >vector1 => ' , ( 1._R4P > vector1 ) print \"(A,L1)\" , '1_I8P  >vector1 => ' , ( 1_I8P > vector1 ) print \"(A,L1)\" , '1_I4P  >vector1 => ' , ( 1_I4P > vector1 ) print \"(A,L1)\" , '1_I2P  >vector1 => ' , ( 1_I2P > vector1 ) print \"(A,L1)\" , '1_I1P  >vector1 => ' , ( 1_I1P > vector1 ) print \"(A,L1)\" , 'vector1>vector2 => ' , ( vector1 > vector2 ) stop endprogram kinds","tags":"","loc":"program/kinds.html","title":"kinds – VecFor"},{"text":"Uses: vecfor program~~simple~~UsesGraph program~simple simple module~vecfor vecfor module~vecfor->program~simple iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf penf module~penf->module~vecfor module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf var panprogramsimpleUsesGraph = svgPanZoom('#programsimpleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Simple regression test for VecFor library. Calls program~~simple~~CallsGraph program~simple simple proc~norml2 normL2 program~simple->proc~norml2 proc~face_normal4 face_normal4 program~simple->proc~face_normal4 proc~sq_norm sq_norm program~simple->proc~sq_norm proc~face_normal3 face_normal3 program~simple->proc~face_normal3 proc~normalize normalize proc~face_normal4->proc~normalize proc~face_normal3->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables vector1 vector2 vector3 vector4 vector5 Source Code simple Variables Type Attributes Name Initial type( vector ) :: vector1 Vector dummy variable. type( vector ) :: vector2 Vector dummy variable. type( vector ) :: vector3 Vector dummy variable. type( vector ) :: vector4 Vector dummy variable. type( vector ) :: vector5 Vector dummy variable. Source Code program simple !< Simple regression test for VecFor library. use vecfor implicit none type ( vector ) :: vector1 !< Vector dummy variable. type ( vector ) :: vector2 !< Vector dummy variable. type ( vector ) :: vector3 !< Vector dummy variable. type ( vector ) :: vector4 !< Vector dummy variable. type ( vector ) :: vector5 !< Vector dummy variable. print \"(A)\" , ' Assign vector1 = [1, 2, 3]' vector1 = 1 * ex + 2 * ey + 3 * ez print \"(A)\" , ' Assign vector2 = [-1, -2, -3]' vector2 = - 1 * ex - 2 * ey - 3 * ez print \"(A)\" , ' Verify auxiliary methods' print \"(A,F5.1)\" , ' vector1%sq_norm() = ' , vector1 % sq_norm () print \"(A,F5.1)\" , ' sq_norm(vector1) = ' , sq_norm ( vector1 ) print \"(A,F5.1)\" , ' vector1%normL2() = ' , vector1 % normL2 () print \"(A,F5.1)\" , ' normL2(vector1) = ' , normL2 ( vector1 ) print \"(A)\" , ' normalized(vector1):' vector3 = vector1 % normalized () call vector3 % print print \"(A)\" , 'call vector1%normalize():' vector3 = vector1 call vector3 % normalize () call vector3 % print print \"(A)\" , ' Verify normalization fall-back for null vector' vector3 = 0 call vector3 % normalize () print \"(A)\" , 'call 0%normalize():' call vector3 % print vector3 = 0 vector3 = vector3 % normalized () print \"(A)\" , 'vector1 = 0%normalized():' call vector3 % print print \"(A)\" , ' Verify dot product' print \"(A,F5.1)\" , ' vector1.dot.ex = ' , vector1 . dot . ex print \"(A,F5.1)\" , ' vector1.dot.ey = ' , vector1 . dot . ey print \"(A,F5.1)\" , ' vector1.dot.ez = ' , vector1 . dot . ez print \"(A,F5.1)\" , ' vector1.dot.vector2 = ' , vector1 . dot . vector2 print \"(A)\" , ' Verify cross product' print \"(A)\" , ' vector1.cross.vector2:' vector3 = vector1 . cross . vector2 call vector3 % print print \"(A)\" , ' Verify special operators' print \"(A)\" , ' vector1.ortho.vector2:' vector3 = vector1 . ortho . vector2 call vector3 % print print \"(A)\" , ' vector1.paral.vector2:' vector3 = vector1 . paral . vector2 call vector3 % print print \"(A)\" , ' Verify * / + - operators' print \"(A)\" , ' vector1 * vector2:' vector3 = vector1 * vector2 call vector3 % print print \"(A)\" , ' vector1 / vector2:' vector3 = vector1 / vector2 call vector3 % print print \"(A)\" , ' vector1 + vector2:' vector3 = vector1 + vector2 call vector3 % print print \"(A)\" , ' vector1 - vector2:' vector3 = vector1 - vector2 call vector3 % print print \"(A)\" , ' Assign vector1 = [-1, 1, 0]' vector1 = - ex + ey print \"(A)\" , ' Assign vector2 = [0, 1, 0]' vector2 = ey print \"(A)\" , ' Assign vector3 = [0, -1, 0]' vector3 = - ey print \"(A)\" , ' Assign vector4 = [-1, -1, 0]' vector4 = - ex - ey print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure):' vector5 = face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (stand alone procedure, normalized):' vector5 = face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method):' call vector5 % face_normal3 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3 normal (type bound method, normalized):' call vector5 % face_normal3 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure): ' vector5 = face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (stand alone procedure, normalized): ' vector5 = face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method):' call vector5 % face_normal4 ( pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A)\" , ' Face 1-2-3-4 normal (type bound method, normalized):' call vector5 % face_normal4 ( norm = 'y' , pt1 = vector1 , pt2 = vector2 , pt3 = vector3 , pt4 = vector4 ) call vector5 % print print \"(A,I3)\" , ' IO length of vector1 = ' , vector1 % iolen () stop endprogram simple","tags":"","loc":"program/simple.html","title":"simple – VecFor"}]}